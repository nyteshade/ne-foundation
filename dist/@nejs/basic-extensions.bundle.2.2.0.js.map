{
  "version": 3,
  "sources": ["../../src/index.js", "../../node_modules/.pnpm/@nejs+extension@2.7.1/node_modules/@nejs/extension/src/errors/CannotBeExtendedError.js", "../../node_modules/.pnpm/@nejs+extension@2.7.1/node_modules/@nejs/extension/src/errors/MissingOwnerValue.js", "../../node_modules/.pnpm/@nejs+extension@2.7.1/node_modules/@nejs/extension/src/patchtoggle.js", "../../node_modules/.pnpm/@nejs+extension@2.7.1/node_modules/@nejs/extension/src/patchentry.js", "../../node_modules/.pnpm/@nejs+extension@2.7.1/node_modules/@nejs/extension/src/patch.js", "../../node_modules/.pnpm/@nejs+extension@2.7.1/node_modules/@nejs/extension/src/extension.js", "../../src/objectextensions.js", "../../src/functionextensions.js", "../../src/mapextensions.js", "../../src/setextensions.js", "../../src/reflectextensions.js", "../../src/stringextensions.js", "../../src/symbolextensions.js", "../../src/arrayextensions.js", "../../src/newClasses/descriptor.js", "../../src/globals.js", "../../src/newClasses/refset.js", "../../src/weakrefextensions.js", "../../src/newClasses/iterable.js", "../../src/newClasses/refmap.js", "../../src/newClasses/deferred.js", "../../src/newClasses/asyncIterable.js"],
  "sourcesContent": ["import { FunctionExtensions, FunctionPrototypeExtensions } from './functionextensions.js'\nimport { ObjectExtensions, ObjectPrototypeExtensions } from './objectextensions.js'\nimport { MapPrototypeExtensions } from './mapextensions.js'\nimport { SetPrototypeExtensions } from './setextensions.js'\nimport { ReflectExtensions } from './reflectextensions.js'\nimport { StringExtensions } from './stringextensions.js'\nimport { SymbolExtensions } from './symbolextensions.js'\nimport { ArrayPrototypeExtensions } from './arrayextensions.js'\nimport { DescriptorExtensions, Descriptor } from './newClasses/descriptor.js'\nimport { GlobalFunctionsAndProps } from './globals.js'\nimport { RefSetExtensions } from './newClasses/refset.js'\nimport { RefMapExtensions } from './newClasses/refmap.js'\nimport { DeferredExtension } from './newClasses/deferred.js'\n\nimport {\n  AsyncIteratorExtensions,\n  AsyncIterableExtensions\n} from './newClasses/asyncIterable.js'\n\nimport {\n  IteratorExtensions,\n  IterableExtensions\n} from './newClasses/iterable.js'\n\nconst StaticPatches = [\n  [Object, ObjectExtensions, Object.name],\n  [Function, FunctionExtensions, Function.name],\n  [Reflect, ReflectExtensions, 'Reflect'],       // Missing a .name property\n  [String, StringExtensions, String.name],\n  [Symbol, SymbolExtensions, 'Symbol'],          // Missing a .name property\n]\n\nconst InstancePatches = [\n  [Object.prototype, ObjectPrototypeExtensions, Object.name],\n  [Function.prototype, FunctionPrototypeExtensions, Function.name],\n  [Array.prototype, ArrayPrototypeExtensions, Array.name],\n  [Map.prototype, MapPrototypeExtensions, Map.name],\n  [Set.prototype, SetPrototypeExtensions, Set.name],\n]\n\nconst Patches = new Map([\n  ...StaticPatches,\n  ...InstancePatches,\n])\n\nconst Extensions = {\n  [AsyncIterableExtensions.key]: AsyncIterableExtensions,\n  [AsyncIteratorExtensions.key]: AsyncIteratorExtensions,\n  [DeferredExtension.key]: DeferredExtension,\n  [DescriptorExtensions.key]: DescriptorExtensions,\n  [IterableExtensions.key]: IterableExtensions,\n  [IteratorExtensions.key]: IteratorExtensions,\n  [RefMapExtensions.key]: RefMapExtensions,\n  [RefSetExtensions.key]: RefSetExtensions,\n}\n\nconst Controls = {}\n\nObject.assign(Controls, {\n  enableAll() {\n    Controls.enablePatches()\n    Controls.enableExtensions()\n  },\n\n  enablePatches() {\n    Patches.forEach((extension) => { extension.apply() })\n  },\n\n  enableStaticPatches(filter = ([owner, extension]) => true) {\n    const patches = StaticPatches.filter(toFilterFn(filter))\n    patches.forEach(([_, extension]) => extension.apply())\n    return patches\n  },\n\n  enableInstancePatches(filter = ([owner, extension]) => true) {\n    const patches = InstancePatches.filter(toFilterFn(filter))\n    patches.forEach(([_, extension]) => extension.apply())\n    return patches\n  },\n\n  enableExtensions() {\n    Object.values(Extensions).forEach((extension) => { extension.apply() })\n    GlobalFunctionsAndProps.apply()\n  },\n\n  disableAll() {\n    Controls.disablePatches()\n    Controls.disableExtensions()\n  },\n\n  disablePatches() {\n    Patches.forEach((extension) => { extension.revert() })\n  },\n\n  disableStaticPatches(filter = ([owner, extension]) => true) {\n    const patches = StaticPatches.filter(toFilterFn(filter))\n    patches.forEach(([_, extension]) => extension.revert())\n    return patches\n  },\n\n  disableInstancePatches(filter = ([owner, extension]) => true) {\n    const patches = InstancePatches.filter(toFilterFn(filter))\n    patches.forEach(([_, extension]) => extension.revert())\n    return patches\n  },\n\n  disableExtensions() {\n    Object.values(Extensions).forEach((extension) => { extension.revert() })\n    GlobalFunctionsAndProps.revert()\n  },\n})\n\nexport const all = (() => {\n  const dest = {\n    patches: {},\n    classes: {},\n    global: {},\n  };\n\n  const entriesReducer = (accumulator, [key, entry]) => {\n    const descriptor = new Descriptor(entry.descriptor, entry.owner)\n\n    descriptor.applyTo(accumulator, key, true)\n\n    return accumulator\n  }\n\n  const staticPatchReducer = (accumulator, [_, patch, ownerName]) => {\n    if (!accumulator?.[ownerName]) {\n      accumulator[ownerName] = {}\n    }\n\n    [...patch].reduce(entriesReducer, accumulator[ownerName])\n    return accumulator\n  };\n\n  const instancePatchReducer = (accumulator, [_, patch, ownerName]) => {\n    if (!accumulator?.[ownerName])\n      accumulator[ownerName] = {};\n    \n    if (!accumulator[ownerName]?.prototype)\n      accumulator[ownerName].prototype = {};    \n\n      [...patch].reduce(entriesReducer, accumulator[ownerName].prototype)\n    return accumulator\n  }\n\n  StaticPatches.reduce(staticPatchReducer, dest.patches);\n  InstancePatches.reduce(instancePatchReducer, dest.patches);\n  (Object.values(Extensions)\n    .flatMap(extension => [...extension])\n    .reduce(entriesReducer, dest.classes)\n  )\n  \n  for (const [key, entry] of GlobalFunctionsAndProps) {\n    const descriptor = new Descriptor(entry.descriptor, entry.owner)\n    Object.defineProperty(dest.global, key, descriptor.toObject(true))\n  }\n\n  return dest  \n})()\n\nconst results = {\n  ...Controls,\n  Extensions,\n  Patches,\n  GlobalFunctionsAndProps,\n  StaticPatches,\n  InstancePatches,\n  Controls,\n  extensions: Extensions,\n  patches: Patches,\n  all,\n}\n\nexport default results\n\nexport {\n  Extensions,\n  Patches,\n  StaticPatches,\n  InstancePatches,\n  Controls,\n  GlobalFunctionsAndProps,\n}\n\nfunction toFilterFn(filter = ([owner, extension]) => true) {\n  let filterFn = filter\n\n  if (typeof filterFn !== 'function') {\n    const elements = Array.isArray(filter) ? filter : [filter]\n    filterFn = ([owner, _]) => {\n      for (const element of elements) {\n        const elementStr = String(element)\n        if (elementStr.startsWith('^')) {\n          if ((owner?.name ?? owner) != elementStr.substring(1)) {\n            return true\n          }\n        }\n        if ((owner?.name ?? owner) == elementStr) {\n          return true\n        }\n      }\n      return false\n    }\n  }\n\n  return filterFn\n}", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n  /**\n   * Constructs a new CannotBeExtendedError instance.\n   *\n   * @param {string} owner The name or identifier of the restricted part\n   * that is disallowing extension or tampering.\n   * @param {string} key The key or property that was attempted to be\n   * modified or extended.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} disallows tampering with ${key}.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n  /**\n   * Constructs a new MissingOwnerValue instance.\n   *\n   * @param {string} owner The object or entity that is supposed to contain the\n   * property.\n   * @param {string} key The name of the property that is missing from the owner.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} does not have a property named '${key}'.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   *\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "import { Patch } from \"./patch\";\n\n/**\n * Early usage of the Patch and Extension classes made it clear that it was\n * cumbersome to use a Patch temporarily for a block of code and excessive\n * amounts of if/else statements were required. This simple wrapper makes that\n * process easier.\n */\nexport class PatchToggle {\n  /**\n   * Wraps an instance of a Patch. It allows low-code clean-readability to\n   * start and stop the underlying patch regardless of whether or not the\n   * patch has been already applied.\n   *\n   * @param {Patch} patch instance of `Patch` to wrap with this toggle\n   * @param {boolean} preventRevert prevents the call to `.revert()` on the\n   * supplied patch when stop() is called.\n   */\n  constructor(patch, preventRevert = false) {\n    this.started = false\n    this.preventRevert = preventRevert\n    this.patch = patch\n    this.patchName = (\n      patch.owner?.name ??\n      patch.owner?.constructor?.name ??\n      /(\\w+)]/.exec(Object.prototype.toString.call(patch.owner))[1]\n    )\n    this.state = {\n      needsApplication: false,\n      needsReversion: false,\n    }\n  }\n\n  /**\n   * If the usage of the wrapped Patch hasn't been started yet, the code checks\n   * whether or not the patch has been applied by checking for signs of it in\n   * the owning object.\n   *\n   * If the patch needs to be applied, it will be applied at this time.\n   *\n   * @returns {PatchToggle} returns `this` to allow for chaining\n   */\n  start() {\n    if (!this.started) {\n      this.state.needsApplication = !this.patch.applied\n      this.state.needsReversion = this.patch.applied\n      this.started = true\n\n      if (this.state.needsApplication) {\n        this.patch.apply()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Checks to see if the toggle has been started. If so, the patch is reverted\n   * if it needed to be applied previously. After stopping, the state of the instance\n   * is reverted to allow for clean subsequent calls to start.\n   *\n   * @returns {PatchToggle} returns `this` to allow further chaining\n   */\n  stop() {\n    if (this.started) {\n      if (this.preventRevert || this.patch.applied) {\n        this.patch.revert()\n      }\n\n      this.state.needsApplication = false\n      this.state.needsReversion = false\n      this.started = false\n    }\n\n    return this\n  }\n\n  /**\n   * When the string tag for this class instance is inspected, it will\n   * reflect the string `PatchToggle:PatchName`\n   */\n  get [Symbol.toStringTag]() {\n    return `${this.constructor.name}:${this.patchName}`\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchToggle instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const objName = this[Symbol.toStringTag]\n    const status = `(started: ${this.started} needed: ${this.state.needsApplication})`\n\n    return inspect(`${objName} ${status}`, {...options, depth})\n  }\n}", "/**\n * A PatchEntry class is a wrapper that maps the descriptor, key and owning\n * object in a single instance. When a Patch or Extension are created, one\n * of these for each patch is created so that the patch can be applied and\n * reverted.\n */\nexport class PatchEntry {\n  /**\n   * Constructs a new PatchEntry instance.\n   *\n   * @param {string|symbol} property The property key to be patched.\n   * @param {object} [owningObject=globalThis] The object from which the\n   * property descriptor is taken.\n   * @param {function} condition if a valid function is passed here, the\n   * expectation is that it takes no parameters and returns a `boolean`. If\n   * `true`, then this entry can be applied. If `false`, it indicates to the\n   * consuming `Patch` that it cannot be applied.\n   * @throws {TypeError} if `owningObject` is not a valid object (i.e. one that\n   * can contain property descriptors and assigned values), then a `TypeError`\n   * is thrown. A `TypeError` is also thrown if `property` is null, or neither\n   * an object nor symbol.\n   */\n  constructor(property, owningObject = globalThis, condition = undefined) {\n    const isNullish = (value) => (value === null || value === undefined)\n    const isKey = (value, types = ['string', 'symbol']) =>\n      !isNullish(value) && (!!types.find(f => f === (typeof value)))\n    const isObject = value => isKey(value, ['object'])\n\n    if (!isKey(property)) {\n      console.error(\n        'Property', property, `(type: ${typeof property})`,\n        'owningObject', owningObject, `(type: ${typeof owningObject})`,\n        'condition', condition, `(type: ${typeof condition})`,\n      )\n      throw new TypeError('Property must be non-null and either a string or symbol')\n    }\n\n    if (!isObject(owningObject)) {\n      throw new TypeError('Cannot create Patch entry as owning object is invalid')\n    }\n\n    Object.assign(this, {\n      key: property,\n      descriptor: Object.getOwnPropertyDescriptor(owningObject, property),\n      owner: owningObject,\n      condition: (typeof condition === 'function') ? condition : undefined\n    })\n  }\n\n  /**\n   * Computes and returns the current value of the patch, based on its type\n   * (data or accessor).\n   *\n   * @returns {any} The current value of the patch.\n   */\n  get computed() {\n    if (this.isAccessor) {\n      return this.descriptor.get.bind(this.owner).call()\n    }\n    else {\n      return this.descriptor.value\n    }\n  }\n\n  /**\n   * Checks if the patch is a data property (has a value).\n   *\n   * @returns {boolean} True if the patch is a data property, false otherwise.\n   */\n  get isData() {\n    return Reflect.has(this.descriptor, 'value')\n  }\n\n  /**\n   * Checks if the patch is an accessor property (has a getter).\n   *\n   * @returns {boolean} True if the patch is an accessor property, false otherwise.\n   */\n  get isAccessor() {\n    return Reflect.has(this.descriptor, 'get')\n  }\n\n  /**\n   * Checks if the patch is read-only (not configurable or not writable).\n   *\n   * @returns {boolean} True if the patch is read-only, false otherwise.\n   */\n  get isReadOnly() {\n    return (\n      (Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n      (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable)\n    )\n  }\n\n  /**\n   * If a `condition` is associated with this specific patch entry, then it will\n   * run and its result will be returned. Otherwise `true` is returned allowing\n   * all non-conditional `PatchEntry` instances to be applied every time.\n   *\n   * @returns {boolean} `true` if the condition is true or there is no condition\n   * applied to this instance. `false` if the condition fails.\n   */\n  get isAllowed() {\n    const validAndPresent = (\n      this.condition &&\n      typeof this.condition === 'function'\n    )\n\n    return validAndPresent ? this.condition() : true\n  }\n\n  /**\n   * Applies the patch entry to a given object. This method takes the\n   * descriptor from the current patch entry and defines it on the target\n   * object. If `bindAccessors` is true and the descriptor contains accessor\n   * methods (getters/setters), they will be bound to the original owner of\n   * the patch before being applied to ensure the correct `this` context.\n   *\n   * @param {object} anotherObject - The object to which the patch will be \n   * applied.\n   * @param {boolean} [bindAccessors=false] - Whether to bind accessor methods \n   * to the patch's owner.\n   */\n  applyTo(anotherObject, bindAccessors = false) {\n    const descriptor = { ...this.descriptor }\n\n    if (bindAccessors) {\n      if (typeof descriptor.get === 'function') {\n        descriptor.get = descriptor.get.bind(this.owner);\n      }\n      if (typeof descriptor.set === 'function') {\n        descriptor.set = descriptor.set.bind(this.owner);\n      }\n    }\n\n    Object.defineProperty(anotherObject, this.key, descriptor);\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name of\n   * the PatchEntry instance.\n   *\n   * @returns {string} The class name of the PatchEntry instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchEntry instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const type = this.isData ? ' Data' : ' Accessor'\n    const writable = this.isReadOnly ? ' [ReadOnly]' : ''\n\n    return `PatchEntry<${this.key}${type}${writable}>`\n  }\n}\n", "import { PatchToggle } from './patchtoggle.js'\nimport { PatchEntry } from './patchentry.js'\n\n/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n  /**\n   * A record of conflicts between existing and patched properties or methods.\n   * This object maps property names to their respective PatchEntry instances,\n   * which contain information about the original and patched values.\n   *\n   * @type {object}\n   */\n  patchConflicts = {}\n\n  /**\n   * An object to store patch entries. Each key corresponds to a property or\n   * method name on the owner object, and the value is the associated\n   * PatchEntry instance which contains the patched and original values.\n   *\n   * @type {object}\n   */\n  patchEntries = {}\n\n  /**\n   * The object containing the patches to be applied to the owner. It is\n   * initially undefined and will be populated with the patches passed to the\n   * constructor.\n   *\n   * @type {object}\n   */\n  patchesOwner = undefined\n\n  /**\n   * The count of patches that have been applied. This is incremented\n   * each time a patch is applied and decremented when a patch is\n   * reverted.\n   *\n   * @type {number}\n   */\n  patchCount = 0\n\n  /**\n   * The number of patches that have been successfully applied. This count\n   * is incremented after each successful patch application and decremented\n   * when a patch is reverted.\n   *\n   * @type {number}\n   */\n  patchesApplied = 0\n\n  /**\n   * Constructs a new Patch instance. Supported options for Patch instances\n   * include either a global condition for the Patch to be applied or\n   * specific property conditions subjecting only a subset of the patches\n   * to conditional application.\n   *\n   * @example\n   * ```\n   * const custom = Symbol.for('nodejs.util.inspect.custom')\n   * const patch = new Patch(\n   *   Object,\n   *   {\n   *     property: 'value',\n   *     [custom](depth, options, inspect) {\n   *       // ... custom return string for nodejs\n   *     }\n   *   },\n   *   {\n   *     conditions: {\n   *       [custom]() { return process?.versions?.node !== null },\n   *     },\n   *   }\n   * )\n   * patch.apply() // applies `property` but only applies the `custom`\n   *               // property if the JavaScript is running in NodeJS\n   * ```\n   *\n   * @param {object} owner The object to which patches will be applied.\n   * @param {object} patches An object containing properties or methods to\n   *                         be patched onto the owner.\n   * @param {object} [options={}] Additional options for patching behavior.\n   */\n  constructor(owner, patches, options = {}) {\n    Object.assign(this, {\n      owner,\n      options,\n    })\n\n    this.patchesOwner = patches\n\n    const globalCondition = this?.options.condition\n\n    Reflect.ownKeys(patches).forEach(key => {\n      const condition = this?.options?.conditions?.[key] ?? globalCondition\n      try {\n        this.patchEntries[key] = new PatchEntry(key, this.patchesOwner, condition)\n        this.patchCount += 1\n      }\n      catch (error) {\n        console.error(`Failed to process patch for ${key}\\n`, error)\n      }\n\n      if (Reflect.has(this.owner, key)) {\n        try {\n          this.patchConflicts[key] = new PatchEntry(key, this.owner)\n        }\n        catch (error) {\n          console.error(`Cannot capture conflicting patch key ${key}\\n`, error)\n        }\n      }\n    })\n\n    if (!Patch.patches.has(owner)) {\n      Patch.patches.set(owner, [])\n    }\n\n    Patch.patches.get(owner).push(this)\n  }\n\n  /**\n   * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get entries() {\n    return Reflect.ownKeys(this.patchEntries).map(key => {\n      return [key, this.patchEntries[key]]\n    })\n  }\n\n  /**\n   * Retrieves an array of patch entries that have been successfully applied.\n   * Each entry is a key-value pair array where the key is the patch identifier\n   * and the value is the corresponding `PatchEntry` object. Only patches with\n   * a state of `true` in `patchState` are included, indicating they are\n   * currently applied to the owner object.\n   *\n   * @returns {Array} An array of [key, patchEntry]\n   * pairs representing the applied patches.\n   */\n  get appliedEntries() {\n    return Reflect.\n      ownKeys(this.patchEntries).\n      filter(key => this.patchState.get(key) === true).\n      map(key => {\n        return [key, this.patchEntries[key]]\n      })\n  }\n\n  /**\n   * Retrieves an array of patch entries that have not been applied. Each entry\n   * is a key-value pair array where the key is the patch identifier and the\n   * value is the corresponding `PatchEntry` object. Only patches with a state\n   * of `false` in `patchState` are included, indicating they are not currently\n   * applied to the owner object.\n   *\n   * @returns {Array} An array of [key, patchEntry]\n   * pairs representing the unapplied patches.\n   */\n  get unappliedEntries() {\n    return Reflect.\n      ownKeys(this.patchEntries).\n      filter(key => this.patchState.get(key) === false).\n      map(key => {\n        return [key, this.patchEntries[key]]\n      })\n  }\n\n  /**\n   * Depending on how the PatchEntry is configured, accessing the patch\n   * by name can be somewhat irritating, so this provides an object with\n   * the actual current patch value at the time patchValues is requested.\n   *\n   * @example let { patch1, patch2 } = patch.patchValues\n   * @returns {object} an object with the patchName mapped to the current\n   * computed patchEntry value.\n   */\n  get patches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      acc[key] = patchEntry.computed\n      return acc\n    }, {})\n  }\n\n  /**\n   * Retrieves an object containing all patches that have been successfully\n   * applied. The object's keys are the patch keys, and the values are the\n   * computed values of the corresponding patch entries. Only patches with\n   * a state of `true` in `patchState` are considered applied.\n   *\n   * @returns {object} An object mapping each applied patch key to its\n   * computed value.\n   */\n  get appliedPatches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      if (this.patchState.get(key) === true) {\n        acc[key] = patchEntry.computed\n      }\n      return acc\n    }, {})\n  }\n\n  /**\n   * Retrieves an object containing all patches that have not been applied.\n   * The object's keys are the patch keys, and the values are the computed\n   * values of the corresponding patch entries. Only patches with a state\n   * of `false` in `patchState` are considered unapplied.\n   *\n   * @example\n   * // Assuming `patch` is an instance of `Patch` and `patch1` is unapplied:\n   * let unapplied = patch.unappliedPatches;\n   * console.log(unapplied); // { patch1: computedValueOfPatch1 }\n   *\n   * @returns {object} An object mapping each unapplied patch key to its\n   * computed value.\n   */\n  get unappliedPatches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      if (this.patchState.get(key) === false) {\n        acc[key] = patchEntry.computed\n      }\n      return acc\n    }, {})\n  }\n\n  /**\n   * Retrieves an array of patch keys.\n   *\n   * This getter returns an array containing only the keys of the patch entries,\n   * which can be useful for iterating over the patches or checking for the\n   * existence of specific patches by key.\n   *\n   * @returns {string[]} An array of patch keys.\n   */\n  get patchKeys() {\n    return this.entries.map(([key, _]) => key)\n  }\n\n  /**\n   * Retrieves the conflict entries (existing properties on the owner that\n   * will be overridden by patches) as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get conflicts() {\n    return Reflect.ownKeys(this.patchConflicts).map(key => {\n      return [key, this.patchConflicts[key]]\n    })\n  }\n\n  /**\n   * Checks to see if the tracked number of applied patches is greater than 0\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get applied() {\n    return this.patchesApplied > 0\n  }\n\n  /**\n   * Provided for semantics, but this method is synonymous with {@link applied}.\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get isPartiallyPatched() {\n    return this.applied\n  }\n\n  /**\n   * Returns true only when the number of tracked patches matches the number\n   * of applied patches.\n   *\n   * @returns {boolean} true if applied patches is equal to the count of patches\n   */\n  get isFullyPatched() {\n    return this.patchCount == this.patchesApplied\n  }\n\n  /**\n   * Applies all patches to the owner object. If a property with the same key\n   * already exists on the owner, it will be overridden. Optionally a callback\n   * can be supplied to the call to revert. If the callback is a valid function,\n   * it will be invoked with an object containing the results of the reversion\n   * of the patch. The callback receives a single parameter which is an object\n   * of counts. It has the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   applied: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   notApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `applied` is the number of patches that were applied\n   * 'errors' is an array of arrays where the first element is the `PatchEntry`\n   * and the second element is an `Error` indicating the problem. An error will\n   * only be generated if `isAllowed` is `true` and the patch still failed to\n   * apply Lastly `notApplied` is the number of patches that were unable to\n   * be applied.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === applied when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 notApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  apply(metrics) {\n    const entries = this.entries\n    const counts = {\n      patches: entries.length,\n      applied: 0,\n      errors: [],\n      notApplied: entries.length,\n    }\n\n    this.patchState.clear()\n\n    entries.forEach(([,patch]) => {\n      if (patch.isAllowed) {\n        // Patch\n        Object.defineProperty(this.owner, patch.key, patch.descriptor)\n\n        // Verify\n        let oDesc = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n        if (this.#equalDescriptors(oDesc, patch.descriptor)) {\n          counts.applied += 1\n          counts.notApplied -= 1\n\n          this.patchState.set(patch, true)\n\n        }\n        else {\n          counts.errors.push([patch, new Error(\n            `Could not apply patch for key ${patch.key}`\n          )])\n          this.patchState.set(patch, false)\n        }\n      }\n      else {\n        this.patchState.set(patch, false)\n      }\n    })\n\n    this.patchesApplied = counts.applied\n\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Creates an easy to use toggle for working with `Patch` classes\n   *\n   * @param {boolean} preventRevert true if calling stop() on the toggle does not\n   * revert the patch. false, the default, if it should.\n   * @returns {PatchToggle} an instance of PatchToggle wrapped around this instance\n   * of `Patch`\n   * @example const toggle = ObjectExtensions.createToggle().start()\n   */\n  createToggle(preventRevert = false) {\n    return new PatchToggle(this, preventRevert)\n  }\n\n  /**\n   * Reverts all applied patches on the owner object, restoring any overridden\n   * properties to their original state. Optionally a callback can be supplied to\n   * the call to revert. If the callback is a valid function, it will be invoked\n   * with an object containing the results of the reversion of the patch. The\n   * callback receives a single parameter which is an object of counts. It has\n   * the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   reverted: number;\n   *   restored: number;\n   *   conflicts: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   stillApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `reverted` is the number of patches that were removed'\n   * `restored` is the number of originally conflicting keys that were restored.\n   * `conflicts` is the total number of conflicts expected. `errors` is an array of\n   * arrays where the first element is the `PatchEntry` and the second element\n   * is an `Error` indicating the problem. Lastly `stillApplied` is the number of\n   * patchesApplied still tracked. If this is greater than zero, you can assume\n   * something went wrong.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === reverted when done\n   *   \u2022 restored should === conflicts when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 stillApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  revert(metrics) {\n    if (!this.applied) {\n      return\n    }\n\n    const entries = this.entries\n    const conflicts = this.conflicts\n\n    const counts = {\n      patches: entries.length,\n      reverted: 0,\n      restored: 0,\n      conflicts: conflicts.length,\n      errors: [],\n      stillApplied: 0,\n    }\n\n    entries.forEach(([,patch]) => {\n      const successful = delete this.owner[patch.key]\n      if (successful) {\n        this.patchesApplied -= 1\n        counts.reverted += 1\n        this.patchState.set(patch, false)\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to revert patch ${patch.key}`\n        )])\n      }\n    })\n\n    conflicts.forEach(([,patch]) => {\n      Object.defineProperty(this.owner, patch.key, patch.descriptor)\n      const appliedDescriptor = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n      if (this.#equalDescriptors(patch.descriptor, appliedDescriptor)) {\n        counts.restored += 1\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to restore original ${patch.key}`\n        )])\n      }\n    })\n\n    counts.stillApplied = this.patchesApplied\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Removes this Patch instance from being tracked amongst all the tracked Patch\n   * instances. The JavaScript virtual machine will clean this instance up once\n   * nothing else is holding a reference to it.\n   */\n  release() {\n    const patches = Patch.patches.get(this.owner)\n    patches.splice(patches.find(e => e === this), 1)\n  }\n\n  /**\n   * The object to which the patches are applied.\n   */\n  owner = null;\n\n  /**\n   * Additional options for patching behavior.\n   */\n  options = null;\n\n  /**\n   * Patches that are currently live and active will have true as their\n   * value and inert or non-applied patches will have false as their\n   * value. The key is always the associated {@link PatchEntry}.\n   */\n  patchState = new Map();\n\n  /**\n   * Creates an iterator for the patch entries, allowing the `Patch` instance to\n   * be directly iterable using a `for...of` loop. Each iteration will yield a\n   * `[key, patchEntry]` pair, where `key` is the property name and `patchEntry`\n   * is the corresponding `PatchEntry` instance.\n   *\n   * @returns {Iterator} An iterator that yields `[key, patchEntry]` pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries.values()\n  }\n\n  /**\n   * Compares two property descriptor objects to determine if they are equivalent.\n   *\n   * This method checks if both descriptors have the same value for the\n   * `configurable`, `enumerable`, `value`, `writable`, `get`, and `set`\n   * properties. If any of these properties differ between the two descriptors,\n   * the descriptors are considered not equivalent.\n   *\n   * @param {PropertyDescriptor} left - The first descriptor to compare.\n   * @param {PropertyDescriptor} right - The second descriptor to compare.\n   * @returns {boolean} - True if the descriptors are equivalent, false otherwise.\n   * @private\n   */\n  #equalDescriptors(left, right) {\n    if (!left || !right) {\n      return false;\n    }\n\n    return (\n      left.configurable === right.configurable &&\n      left.enumerable === right.enumerable &&\n      left.value === right.value &&\n      left.writable === right.writable &&\n      left.get === right.get &&\n      left.set === right.set\n    )\n  }\n\n  /**\n   * Custom inspection function for Node.js that is called when `util.inspect`\n   * is used to convert the instance to a string. This allows for customizing\n   * the output of `util.inspect` for objects of this class.\n   *\n   * @param {number} depth The current depth of the inspection. If the depth\n   * is less than the recurse times set, it will return the object itself,\n   * otherwise it will return the inspected result.\n   * @param {object} options An object containing options for the inspection.\n   * @param {function} inspect The inspection function provided by Node.js\n   * that can be called to inspect other properties with the same options as\n   * the original call.\n   * @returns {string} A string representation of the instance tailored for\n   * Node.js' `util.inspect`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const exprs = {\n      get quotes() { return /^(\\x1B\\[\\d+m)?['\"]|[\"'](\\x1B\\[\\d+m)?$/g },\n      get arrays() { return /^(\\x1B\\[\\d+m)?\\[ | \\](\\x1B\\[\\d+m)?$/g },\n    }\n    const opts = { ...options, depth };\n    const type = this.owner?.name ?? ''\n    const name = (type.length\n      ? `[${inspect(type, options).replaceAll(exprs.quotes, '$1$2')}]`\n      : ''\n    )\n    const keys = (\n      inspect(this.patchKeys, opts)\n        .replaceAll(exprs.arrays, '$1$2')\n        .replaceAll(/'(.*?)'/g, \"$1\")\n    )\n    return `${this.constructor.name}${name} { ${keys} }`;\n  }\n\n  /**\n   * A global mapping of all patches in play\n   */\n  static patches = new Map()\n\n  /**\n   * Applies all patches associated with a given owner object. This method\n   * is used to enable all patches for a specific owner if they have been\n   * previously registered.\n   *\n   * @param {object} owner The object whose patches are to be applied.\n   */\n  static enableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.apply()\n      }\n    }\n  }\n\n  /**\n   * Reverts all patches associated with a given owner object. This method\n   * is used to disable all patches for a specific owner if they have been\n   * previously applied.\n   *\n   * @param {object} owner The object whose patches are to be reverted.\n   */\n  static disableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.revert()\n      }\n    }\n  }\n\n  /**\n   * A static getter that provides a proxy to manage and interact with the\n   * patches that have been applied globally. This proxy abstracts the\n   * underlying details and presents a simplified interface for querying and\n   * manipulating applied patches. It is particularly useful in IDEs, as it\n   * allows developers to access the state of applied patches without needing\n   * to delve into the source code.\n   *\n   * @returns {Object} An object showing all the keys known to be patched for\n   * the default owner, `globalThis`\n   */\n  static get applied() {\n    return this.#allPatchesForOwner(globalThis, true)\n  }\n\n  /**\n   * A static getter that provides access to a proxy representing all known\n   * patches, whether applied or not. This is useful for inspecting the\n   * complete set of patches that have been registered in the system, without\n   * limiting the view to only those that are currently active. The proxy\n   * abstracts the underlying details and presents a simplified interface for\n   * querying and manipulating the patches.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of all\n   * registered patches, allowing for operations like checking if a patch is\n   * known and retrieving patch values.\n   */\n  static get known() {\n    return this.#allPatchesForOwner(globalThis, false)\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with a toggle functionality. This proxy allows the temporary\n   * application of patches within a certain scope, and automatically reverts\n   * them after the scope ends. It is useful for applying patches in a\n   * controlled manner, ensuring that they do not remain active beyond the\n   * intended usage.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with toggle functionality, allowing for temporary application\n   * and automatic reversion of patches.\n   */\n  static get use() {\n    return this.#allPatchesForOwner(globalThis, false, true)\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with lazy initialization. This proxy defers the creation and\n   * application of patches until they are explicitly requested. It is\n   * beneficial for performance optimization, as it avoids the overhead of\n   * initializing patches that may not be used.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with lazy initialization, allowing patches to be created and\n   * applied only when needed.\n   */\n  static get lazy() {\n    return this.#allPatchesForOwner(globalThis, false, false, true)\n  }\n\n  /**\n   * Returns an object with getters to access different proxy views of patches\n   * scoped to a specific owner. This allows for interaction with patches\n   * that are either applied, known, or used within a certain scope, providing\n   * a controlled environment for patch management.\n   *\n   * @param {object} owner - The object to scope the patch proxies to.\n   * @returns {object} An object containing getters for `applied`, `known`,\n   * and `use` proxies:\n   * - `applied`: Proxy for patches applied to the owner.\n   * - `known`: Proxy for all patches known to the owner, applied or not.\n   * - `use`: Proxy that allows temporary application of patches.\n   */\n  static scopedTo(owner) {\n    const allForOwner = (\n      owner,\n      appliedOnly,\n      wrapInToggle = false,\n      applyOnRequest = false\n    ) => {\n      return this.#allPatchesForOwner(\n        owner,\n        appliedOnly,\n        wrapInToggle,\n        applyOnRequest\n      )\n    }\n\n    return {\n      /**\n       * Getter for a proxy that represents patches applied to the owner.\n       * This proxy provides a simplified interface for interacting with\n       * applied patches, such as checking their status or retrieving values.\n       *\n       * @returns {Proxy} A proxy to the applied patches.\n       */\n      get applied() {\n        return allForOwner(owner, true, false)\n      },\n\n      /**\n       * Getter for a proxy that represents all patches known to the owner,\n       * whether they are applied or not. This proxy allows for querying\n       * and manipulation of the patches without directly accessing them.\n       *\n       * @returns {Proxy} A proxy to all known patches.\n       */\n      get known() {\n        return allForOwner(owner, false, false)\n      },\n\n      /**\n       * Getter for a proxy that enables temporary application of patches\n       * within a certain scope. The patches are automatically reverted\n       * after the scope ends, ensuring controlled usage.\n       *\n       * @returns {Proxy} A proxy to patches with toggle functionality.\n       */\n      get use() {\n        return allForOwner(owner, false, true)\n      },\n\n      /**\n       * Getter for a proxy that represents patches that are not immediately\n       * applied but are applied on request. This allows for patches to be\n       * applied only when they are explicitly needed, potentially improving\n       * performance by deferring the application of patches until necessary.\n       *\n       * @returns {Proxy} A proxy to patches that are applied on request.\n       */\n      get lazy() {\n        return allForOwner(owner, false, false, true)\n      },\n    }\n  }\n\n  /**\n   * Aggregates patches for a given owner into a single object, optionally\n   * filtering by applied status and wrapping in a toggle function.\n   *\n   * This method collects all patches associated with the specified owner\n   * and constructs an object where each patch is represented by its key.\n   * If `onlyApplied` is true, only patches that are currently applied will\n   * be included. If `wrapInToggle` is true, each patch will be represented\n   * as a function that temporarily applies the patch when called.\n   *\n   * @param {object} owner - The owner object whose patches are to be\n   * aggregated.\n   * @param {boolean} onlyApplied - If true, only include patches that\n   * are applied.\n   * @param {boolean} [wrapInToggle=false] - If true, wrap patches in a\n   * toggle function for temporary application.\n   * @returns {object} An object representing the aggregated patches, with\n   * each patch keyed by its property name.\n   * @private\n   */\n  static #allPatchesForOwner(\n    owner,\n    onlyApplied,\n    wrapInToggle = false,\n    applyOnRequest = false\n  ) {\n    return [...Patch.patches.values()].\n      flat().\n      filter(patch => patch.owner === owner).\n      reduce((accumulator, patch) => {\n        for (const [,patchEntry] of patch.entries) {\n          if (onlyApplied && patch.patchState.get(patchEntry) !== true) {\n            continue\n          }\n\n          if (wrapInToggle) {\n            accumulator[patchEntry.key] = async (usage) => {\n              if (typeof usage !== 'function') {\n                return\n              }\n\n              const type = Object.prototype.toString.call(usage)\n              const toggle = patch.createToggle()\n\n              toggle.start()\n              if('[object AsyncFunction]' === type) {\n                await usage(patchEntry.computed, patchEntry)\n              }\n              else {\n                usage(patchEntry.computed, patchEntry)\n              }\n              toggle.stop()\n            }\n\n            continue\n          }\n\n          if (applyOnRequest) {\n            Object.defineProperty(accumulator, patchEntry.key, {\n              get() {\n                patch.apply()\n                return patchEntry.computed\n              },\n              enumerable: true,\n              configurable: true,\n            });\n\n            continue;\n          }\n\n\n          if (patchEntry.isAccessor) {\n            let dynName = `applyAccessorFor_${String(patchEntry.key)}`\n            let dynNameContainer = {\n              [dynName](applyTo) {\n                patchEntry.applyTo(applyTo)\n                return applyTo\n              }\n            };\n\n            accumulator[patchEntry.key] = dynNameContainer[dynName]\n          }\n          else {\n            patchEntry.applyTo(accumulator)\n          }\n        }\n\n        return accumulator\n      }, {})\n  }\n\n  /**\n   * A getter for the custom inspect symbol used by Node.js.\n   *\n   * @returns {symbol} The custom inspect symbol.\n   */\n  static get CustomInspect() {\n    return Symbol.for('nodejs.util.inspect.custom')\n  }\n\n  /**\n   * Strips leading and trailing control characters, brackets, braces, and\n   * quotes from a string. This is typically used to clean strings that may\n   * have special characters or escape sequences that are not desired in the\n   * output.\n   *\n   * @param {string} fromString The string to be stripped of extras.\n   * @returns {string} The cleaned string with extras stripped.\n   */\n  static stripExtras(fromString) {\n    return fromString\n      .replaceAll(\n        /^(\\x1B\\[\\d+m)?[\\[\\{]\\s?|\\s?[\\]\\}](\\x1B\\[\\d+m)?$/gm,\n        '$1$2'\n      )\n      .replaceAll(\n        /['\"](.*?)['\"]/gm,\n        '$1'\n      )\n  }\n}", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\"\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\nimport { Patch } from './patch.js'\n\n/** Shared array of primitive types for use with `isPrimitive` */\nconst primitives = ['number', 'boolean', 'bigint', 'string', 'symbol']\n\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n  /**\n   * Constructs a new Extension instance. This constructor initializes the extension\n   * by determining the target key and value for the extension and ensuring that\n   * the property to be extended is configurable and writable. It throws an error\n   * if these conditions are not satisfied. The constructor leverages the Patch\n   * class's functionalities to manage the extension effectively.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function to be\n   * used for the extension. If a function or class is provided, its name is used\n   * as the key.\n   * @param {*} value - The value or method to be used for the extension.\n   * @param {object} [owner=globalThis] - The object to which the extension will\n   * be applied.\n   * @param {object} [options={}] - Additional options for the extension behavior.\n   * @throws {CannotBeExtendedError} If the target property is not writable or\n   * configurable.\n   * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n   * is an error determining the key and extension values, MissingOwnerValue is\n   * thrown.\n   */\n  constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n    const metadata = Extension.determineInput(keyClassOrFn)\n    let { key, extension, valid } = metadata\n    extension = value || extension\n\n    if (!valid) {\n      throw new MissingOwnerValue(owner, key)\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(owner, key)\n    if (descriptor) {\n      if (\n        (Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n        (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)\n      ) {\n        throw new CannotBeExtendedError(owner, key)\n      }\n    }\n\n    super(owner, { [key]: extension }, options)\n    this.key = key\n\n    this.class = metadata.class\n    this.function = metadata.function\n  }\n\n  /**\n   * Returns true if this `Extension` represents a `function`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a `function`, or\n   * `false` if it does not\n   */\n  get isFunction() { return !!(this.function) }\n\n  /**\n   * Returns true if this `Extension` represents a `class`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a `class`, or\n   * `false` if it does not\n   */\n  get isClass() { return !!(this.class) }\n\n  /**\n   * Returns true if this `Extension` represents a `primitive`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a\n   * primitive value or `false` if it does not.\n   */\n  get isPrimitive() {\n    return ~primitives.indexOf(typeof this.value)\n  }\n\n  /**\n   * Returns true if this `Extension` represents a value that is not\n   * coerced into an `Object` wrapper when wrapped with `Object(value)`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a value\n   * that is alrady an `object`, `false` otherwise.\n   */\n  get isObject() {\n    return Object(this.value) === this.value\n  }\n\n  /**\n   * A static getter that provides a proxy to manage and interact with the\n   * patches that have been applied globally. This proxy abstracts the\n   * underlying details and presents a simplified interface for querying and\n   * manipulating applied patches. It is particularly useful in IDEs, as it\n   * allows developers to access the state of applied patches without needing\n   * to delve into the source code.\n   *\n   * @returns {Object} An object showing all the keys known to be patched for\n   * the default owner, `globalThis`\n   */\n  static get applied() {\n    return Patch.applied;\n  }\n\n  /**\n   * A static getter that provides access to a proxy representing all known\n   * patches, whether applied or not. This is useful for inspecting the\n   * complete set of patches that have been registered in the system, without\n   * limiting the view to only those that are currently active. The proxy\n   * abstracts the underlying details and presents a simplified interface for\n   * querying and manipulating the patches.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of all\n   * registered patches, allowing for operations like checking if a patch is\n   * known and retrieving patch values.\n   */\n  static get known() {\n    return Patch.known;\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with a toggle functionality. This proxy allows the temporary\n   * application of patches within a certain scope, and automatically reverts\n   * them after the scope ends. It is useful for applying patches in a\n   * controlled manner, ensuring that they do not remain active beyond the\n   * intended usage.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with toggle functionality, allowing for temporary application\n   * and automatic reversion of patches.\n   */\n  static get use() {\n    return Patch.use;\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with lazy initialization. This proxy defers the creation and\n   * application of patches until they are explicitly requested. It is\n   * beneficial for performance optimization, as it avoids the overhead of\n   * initializing patches that may not be used.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with lazy initialization, allowing patches to be created and\n   * applied only when needed.\n   */\n  static get lazy() {\n    return Patch.lazy;\n  }\n\n\n  /**\n   * Returns an object with getters to access different proxy views of patches\n   * scoped to a specific owner. This allows for interaction with patches\n   * that are either applied, known, or used within a certain scope, providing\n   * a controlled environment for patch management.\n   *\n   * @param {object} owner - The object to scope the patch proxies to.\n   * @returns {object} An object containing getters for `applied`, `known`,\n   * and `use` proxies:\n   * - `applied`: Proxy for patches applied to the owner.\n   * - `known`: Proxy for all patches known to the owner, applied or not.\n   * - `use`: Proxy that allows temporary application of patches.\n   */\n  static scopedTo(owner) {\n    return Patch.scopedTo(owner);\n  }\n\n  /**\n   * Determines the input type for the extension. This method processes the input\n   * and identifies the key for the extension and the associated value or method.\n   * It supports inputs as either a string key or a function/class, providing\n   * flexibility in defining extensions.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function provided\n   * as input. If a function or class is provided, its name is used as the key.\n   * containing the determined key, the extension value/method, and a validity flag\n   * indicating whether the input is usable.\n   * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n   */\n  static determineInput(keyClassOrFn) {\n    let input = { key: null, extension: null, valid: false }\n\n    if (keyClassOrFn instanceof Function) {\n      input = {\n        key: keyClassOrFn.name,\n        extension: keyClassOrFn,\n        valid: true\n      }\n\n      if (/^class .*/.exec(keyClassOrFn.toString())) {\n        input.class = keyClassOrFn\n      }\n\n      if (/^(async )?function .*/.exec(keyClassOrFn.toString())) {\n        input.function = keyClassOrFn\n      }\n    }\n    else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n      input = { key: keyClassOrFn, extension: null, valid: true }\n    }\n\n    return input\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the Extension instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the Extension instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const exprs = {\n      get braces() { return /^(\\x1B\\[\\d+m)?[\\[\\{]|[\\]\\}](\\x1B\\[\\d+m)?$/g },\n      get quotes() { return /^(\\x1B\\[\\d+m)?['\"]|[\"'](\\x1B\\[\\d+m)?$/g },\n    }\n\n    const key = inspect(this.key, options).replaceAll(exprs.quotes, '$1$2')\n    const val = (\n      inspect(this.patches[this.key], options)\n      .replaceAll(exprs.braces, '$1$2')\n    )\n\n    return `Extension[${key}:${val}]`\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name when the\n   * object is converted to a string, typically used for debugging and logging.\n   *\n   * @returns {string} The class name of the Extension instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Creates a new ExtensionSet with the provided name and extensions.\n   *\n   * @param {string} name - The name of the extension set.\n   * @param {...Extension|Function} extensions - A list of extensions or\n   * functions to include in the set.\n   * @returns {ExtensionSet} A new instance of ExtensionSet containing the\n   * given extensions.\n   */\n  static createSet(name, ...extensions) {\n    return new Extension.ExtensionSet(name, ...extensions)\n  }\n\n  /**\n   * Represents a set of extensions.\n   */\n  static ExtensionSet = class ExtensionSet {\n    /**\n     * Creates an instance of ExtensionSet.\n     *\n     * @param {string} name - The name of the extension set.\n     * @param {...(Extension|Function)} extensions - Extensions or functions to\n     * add to the set.\n     */\n    constructor(name, ...extensions) {\n      this.name = name;\n      this.extensionObjects = new Set();\n      this.extensions = new Set();\n\n      for (const extensionValue of extensions) {\n        if (extensionValue instanceof Extension) {\n          this.extensions.add(extensionValue);\n          this.extensionObjects.add(extensionValue.patches[extensionValue.key]);\n        } else if (extensionValue instanceof Function) {\n          this.extensionObjects.add(extensionValue);\n          this.extensions.add(new Extension(extensionValue));\n        }\n      }\n    }\n\n    /**\n     * Applies all extensions in the set.\n     */\n    apply() {\n      for (const extension of this.extensions) {\n        extension.apply();\n      }\n    }\n\n    /**\n     * Reverts all extensions in the set.\n     */\n    revert() {\n      for (const extension of this.extensions) {\n        extension.revert();\n      }\n    }\n  }\n}", "import { Patch } from '@nejs/extension';\n\n/**\n * `ObjectExtensions` is a patch for the JavaScript built-in `Object` class.\n * It adds utility methods to the `Object` class without modifying the global\n * namespace directly. This patch includes methods for key validation, object\n * type checking, and retrieving the string tag of an object. These methods\n * are useful for enhancing the capabilities of the standard `Object` class\n * with additional utility functions.\n */\nexport const ObjectExtensions = new Patch(Object, {\n  /**\n   * The function checks if a value is either `undefined` or `null`.\n   *\n   * @param {any} value - The parameter \"value\" is a variable that can hold\n   * any value.\n   * @returns {boolean} `true` if the value is either `undefined` or `null`,\n   * and `false` otherwise.\n   */\n  isNullDefined(value) {\n    return value === undefined || value === null\n  },\n\n  /**\n   * Checks to see if the supplied `value` is both an object, and has the\n   * appropriate symbol defined.\n   *\n   * @param {any} value the value to determine if it contains a defined\n   * `Symbol.toStringTag` defined.\n   * @returns true if the symbol is defined, false otherwise\n   */\n  hasStringTag(value) {\n    return Object.isObject(value) && Reflect.has(value, Symbol.toStringTag)\n  },\n\n  /**\n   * Retrieves the string tag of an object. The string tag is a representation\n   * of the object's type, as defined by its `Object.prototype.toString`\n   * method. This utility method is helpful for getting a more descriptive\n   * type of an object than what is returned by the `typeof` operator,\n   * especially for custom objects.\n   *\n   * @param {*} value - The object whose string tag is to be retrieved.\n   * @param {boolean} strict - if this is set to true, undefined will be\n   * returned whenever a supplied object does not have a\n   * `Symbol.toStringTag` defined, period. if false, the default,\n   * @returns {string} - The string tag of the object, indicating its type.\n   */\n  getStringTag(value, strict = false) {\n    if (Object.hasStringTag(value)) {\n      return value[Symbol.toStringTag]\n    }\n\n    if (strict) {\n      return undefined\n    }\n\n    if (value && (typeof value === 'function')) {\n      return value.name\n    }\n\n    return /\\s(.+)]/.exec(Object.prototype.toString.call(value))[1];\n  },\n\n  /**\n   * Determines the type of the given value based on its string tag. This method\n   * uses `Object.getStringTag` to obtain the string tag of the value, which\n   * represents its more specific type (e.g., Array, Map, Set) rather than just\n   * 'object'. The method then maps this string tag to the corresponding type\n   * present in the provided `owner` object, which defaults to `globalThis`.\n   * This utility method is especially useful for identifying the specific\n   * constructor or class of an object, beyond the basic types identified by\n   * the `typeof` operator.\n   *\n   * @param {any} value - The value whose type is to be determined.\n   * @param {object} [owner=globalThis] - The object in which to look up the\n   * constructor corresponding to the string tag. Defaults to `globalThis`,\n   * which covers global constructors like `Array`, `Object`, etc.\n   * @returns {Function|object|null|undefined} - Returns the constructor or\n   * type of the value based on its string tag. For 'Null' and 'Undefined',\n   * it returns `null` and `undefined`, respectively. For other types, it\n   * returns the corresponding constructor (e.g., `Array` for arrays) if\n   * available in the `owner` object.\n   */\n  getType(value, owner = globalThis) {\n    const stringTag = Object.getStringTag(value)\n\n    switch (stringTag) {\n      case 'Null': return null\n      case 'Undefined': return undefined\n      default:\n        return owner[stringTag]\n    }\n  },\n\n  /**\n   * Determines if the provided value is an object. This method checks whether\n   * the value is an instance of `Object` or if its type is 'object'. It's a\n   * utility method for type-checking, ensuring that a value is an object\n   * before performing operations that are specific to objects.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} - Returns `true` if the value is an object,\n   * otherwise `false`.\n   */\n  isObject(value) {\n    return value && (value instanceof Object || typeof value === 'object');\n  },\n\n  /**\n   * Checks to see if the supplied value is a primitive value.\n   *\n   * @param {any} value the value to test to see if it is a primitive value type\n   * @returns true if the object is considered widely to be a primitive value,\n   * false otherwise.\n   */\n  isPrimitive(value) {\n    // Check for null as a special case because typeof null\n    // is 'object'\n    if (value === null) {\n      return true;\n    }\n\n    // Check for other primitives\n    switch (typeof value) {\n      case 'string':\n      case 'number':\n      case 'bigint':\n      case 'boolean':\n      case 'undefined':\n      case 'symbol':\n        return true;\n      default:\n        return false;\n    }\n  },\n\n  /**\n   * Checks if the given value is a valid key for an object. In JavaScript, a\n   * valid key can be either a string or a symbol. This method is useful for\n   * validating object keys before using them in operations like setting or\n   * getting object properties.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} - Returns `true` if the value is a valid object key\n   * (string or symbol), otherwise `false`.\n   */\n  isValidKey(value) {\n    return (typeof value === 'string' || typeof value === 'symbol');\n  },\n\n  /**\n   * Strips an object down to only the keys specified. Optionally, any\n   * accessors can be made to retain their context on the source object.\n   *\n   * @param {object} object the object to pare down\n   * @param {Array<string|symbol>} keys the keys that should appear in the\n   * final reduced object\n   * @param {boolean} [bindAccessors = true] if this value is true then any\n   * accessors from the source object will continue to have their `this`\n   * value bound to the source. If the getter or setter on that object is\n   * defined using an arrow function, this will not work as intended.\n   * @returns {object} an object containing only the keys and symbols\n   * specified in the `keys` parameter.\n   */\n  stripTo(object, keys, bindAccessors = true) {\n    if (!object || typeof object !== 'object') {\n      throw new TypeError(\n        'Object.stripTo requires an object to strip. Received',\n        object\n      );\n    }\n\n    const result = {};\n\n    if (!Array.isArray(keys)) {\n      return result;\n    }\n\n    for (let key of keys) {\n      if (Reflect.has(object, key)) {\n        const originalDescriptor = Object.getOwnPropertyDescriptor(object, key);\n        const descriptor = { ...originalDescriptor };\n\n        if (\n          typeof descriptor.get === 'function' ||\n          typeof descriptor.set === 'function'\n        ) {\n          if (bindAccessors) {\n            descriptor.get = descriptor.get?.bind(object);\n            descriptor.set = descriptor.set?.bind(object);\n          }\n        }\n\n        Object.defineProperty(result, key, descriptor);\n      }\n    }\n\n    return result;\n  },\n});\n\nexport const ObjectPrototypeExtensions = new Patch(Object.prototype, {\n  /**\n   * Strips an object down to only the keys specified. Optionally, any\n   * accessors can be made to retain their context on the source object.\n   * This is a passthrough to the static {@link Object.stripTo} function\n   *\n   * @param {Array<string|symbol>} keys the keys that should appear in the\n   * final reduced object\n   * @param {boolean} [bindAccessors = true] if this value is true then any\n   * accessors from the source object will continue to have their `this`\n   * value bound to the source. If the getter or setter on that object is\n   * defined using an arrow function, this will not work as intended.\n   * @returns {object} an object containing only the keys and symbols\n   * specified in the `keys` parameter.\n   */\n  stripTo(keys, bindAccessors = true) {\n    return Object.stripTo(this, keys, bindAccessors)\n  }\n})\n", "import { Patch } from '@nejs/extension'\nimport { ObjectExtensions } from './objectextensions.js'\n\nconst { getStringTag } = ObjectExtensions.patches\n\n/**\n * The `FunctionExtensions` class is a patch applied to the built-in JavaScript\n * `Function` constructor. It extends `Function` with additional utility methods\n * for determining the specific type or nature of function-like objects. These\n * methods allow developers to distinguish between classes, regular functions,\n * async functions, and arrow functions in a more intuitive and straightforward\n * manner. This class is part of the `@nejs/extension` library and enhances the\n * capabilities of function handling and introspection in JavaScript.\n */\nexport const FunctionExtensions = new Patch(Function, {\n  /**\n   * Determines if a given value is an asynchronous function. It checks if the\n   * value is an instance of `Function` and if its string representation\n   * includes the keyword 'Async'. This method is particularly useful for\n   * identifying async functions.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is an async function,\n   * otherwise `false`.\n   */\n  isAsync(value) {\n    const stringTag = /(\\w+)]/g.exec(Object.prototype.toString.call(value))[1]\n    return (\n      value instanceof Function &&\n      stringTag.includes('Async')\n    )\n  },\n\n  /**\n   * The function checks if a given value is an async generator function\n   *\n   * @param {any} value - The `value` parameter is the value that we want to\n   * check if it is a generator function.\n   * @returns {boolean} `true` if the value is an instance of a function and\n   * its string tag is 'AsyncGeneratorFunction', otherwise it returns `false`.\n   */\n  isAsyncGenerator(value) {\n    const stringTag = getStringTag(value)\n\n    return (\n      value instanceof Function &&\n      stringTag == 'AsyncGeneratorFunction'\n    )\n  },\n\n  /**\n   * Checks if a given value is an arrow function. It verifies if the value is\n   * an instance of `Function`, if its string representation includes the '=>'\n   * symbol, and if it lacks a prototype, which is a characteristic of arrow\n   * functions in JavaScript.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is an arrow function,\n   * otherwise `false`.\n   */\n  isBigArrow(value) {\n    return (\n      value instanceof Function &&\n      String(value).includes('=>') &&\n      !String(value).startsWith('bound') &&\n      !Reflect.has(value, 'prototype')\n    );\n  },\n\n  /**\n   * Determines if a given value is a bound function. Bound functions are\n   * created using the `Function.prototype.bind` method, which allows setting\n   * the `this` value at the time of binding. This method checks if the value\n   * is an instance of `Function`, if its string representation starts with\n   * 'bound', and if it lacks a `prototype` property. These characteristics\n   * are indicative of bound functions in JavaScript.\n   *\n   * @param {*} value - The value to be checked, typically a function.\n   * @returns {boolean} Returns `true` if the value is a bound function,\n   * otherwise `false`. Bound functions have a specific format in their\n   * string representation and do not have their own `prototype` property.\n   */\n  isBound(value) {\n    return (\n      value instanceof Function &&\n      String(value).startsWith('bound') &&\n      !Reflect.has(value, 'prototype')\n    )\n  },\n\n  /**\n   * Determines if a given value is a class. It checks if the value is an\n   * instance of `Function` and if its string representation includes the\n   * keyword 'class'. This method is useful for distinguishing classes from\n   * other function types in JavaScript.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is a class, otherwise\n   * `false`.\n   */\n  isClass(value) {\n    return value instanceof Function && !!/^class\\s/.exec(String(value))\n  },\n\n  /**\n   * Checks if a given value is a regular function. This method verifies if\n   * the value is an instance of `Function`, which includes regular functions,\n   * classes, and async functions but excludes arrow functions.\n   *\n   * @param {*} value - The value to be checked.\n   * @returns {boolean} Returns `true` if the value is a regular function,\n   * otherwise `false`.\n   */\n  isFunction(value) {\n    return value instanceof Function && !Function.isClass(value);\n  },\n\n  /**\n   * The function checks if a given value is a generator function\n   *\n   * @param {any} value - The `value` parameter is the value that we want to\n   * check if it is a generator function.\n   * @returns {boolean} `true` if the value is an instance of a function and\n   * its string tag is 'GeneratorFunction', otherwise it returns `false`.\n   */\n  isGenerator(value) {\n    const stringTag = getStringTag(value)\n\n    return (\n      value instanceof Function &&\n      stringTag == 'GeneratorFunction'\n    )\n  },\n})\n\nexport const FunctionPrototypeExtensions = new Patch(Function.prototype, {\n  /**\n   * Determines if a given value is an asynchronous function. It checks if the\n   * value is an instance of `Function` and if its string representation\n   * includes the keyword 'Async'. This method is particularly useful for\n   * identifying async functions.\n   *\n   * @returns {boolean} Returns `true` if the value is an async function,\n   * otherwise `false`.\n   */\n  get isAsync() {\n    return Function.isAsync(this)\n  },\n\n  /**\n   * The function checks if a given value is an async generator function\n   *\n   * @returns {boolean} `true` if the value is an instance of a function and\n   * its string tag is 'AsyncGeneratorFunction', otherwise it returns `false`.\n   */\n  get isAsyncGenerator() {\n    return Function.isAsyncGenerator(this)\n  },\n\n  /**\n   * Checks if a given value is an arrow function. It verifies if the value is\n   * an instance of `Function`, if its string representation includes the '=>'\n   * symbol, and if it lacks a prototype, which is a characteristic of arrow\n   * functions in JavaScript.\n   *\n   * @returns {boolean} Returns `true` if the value is an arrow function,\n   * otherwise `false`.\n   */\n  get isBigArrow() {\n    return Function.isBigArrow(this)\n  },\n\n  /**\n   * Determines if a given value is a bound function. Bound functions are\n   * created using the `Function.prototype.bind` method, which allows setting\n   * the `this` value at the time of binding. This method checks if the value\n   * is an instance of `Function`, if its string representation starts with\n   * 'bound', and if it lacks a `prototype` property. These characteristics\n   * are indicative of bound functions in JavaScript.\n   *\n   * @returns {boolean} Returns `true` if the value is a bound function,\n   * otherwise `false`. Bound functions have a specific format in their\n   * string representation and do not have their own `prototype` property.\n   */\n  get isBound() {\n    return Function.isBound(this)\n  },\n\n  /**\n   * Determines if a given value is a class. It checks if the value is an\n   * instance of `Function` and if its string representation includes the\n   * keyword 'class'. This method is useful for distinguishing classes from\n   * other function types in JavaScript.\n   *\n   * @returns {boolean} Returns `true` if the value is a class, otherwise\n   * `false`.\n   */\n  get isClass() {\n    return Function.isClass(this)\n  },\n\n  /**\n   * Checks if a given value is a regular function. This method verifies if\n   * the value is an instance of `Function`, which includes regular functions,\n   * classes, and async functions but excludes arrow functions.\n   *\n   * @returns {boolean} Returns `true` if the value is a regular function,\n   * otherwise `false`.\n   */\n  get isFunction() {\n    return Function.isFunction(this)\n  },\n\n  /**\n   * The function checks if a given value is a generator function\n   *\n   * @returns {boolean} `true` if the value is an instance of a function and\n   * its string tag is 'GeneratorFunction', otherwise it returns `false`.\n   */\n  get isGenerator() {\n    return Function.isGenerator(this)\n  },\n})", "import { Patch } from '@nejs/extension';\n\nexport const MapPrototypeExtensions = new Patch(Map.prototype, {\n  /**\n   * The function `getKey` returns the key associated with a given value\n   * in a map.\n   *\n   * @param {any} value - The value parameter is the value that you want to\n   * find the corresponding key for in the map.\n   * @param [strict=true] - The \"strict\" parameter is a boolean value that\n   * determines whether strict equality (===) or loose equality (==) should\n   * be used when comparing the \"value\" parameter with the values in the\n   * entries of the object. If \"strict\" is set to true, strict equality will\n   * be used.\n   * @returns the key associated with the given value. If a matching key is\n   * found, it is returned. If no matching key is found, null is returned.\n   */\n  getKey(value, strict = true) {\n    for (const [key, entryValue] of this) {\n      if (\n        (strict && value === entryValue) &&\n        (!strict && value == entryValue)\n      ) {\n        return key\n      }\n\n      return null\n    }\n  },\n})", "import { Patch } from '@nejs/extension';\n\nexport const SetPrototypeExtensions = new Patch(Set.prototype, {\n  /**\n   * Merges multiple iterables into the set. Each element from the iterables\n   * is added to the set, ensuring uniqueness of all elements. This method\n   * mutates the original set.\n   *\n   * @param {...Iterable} iterables - One or more iterable objects (like Set\n   * or Array) whose elements will be added to the set.\n   */\n  concat(...iterables) {\n    for (const iterable of iterables) {\n      if (\n        typeof iterable === 'string' ||\n        !Reflect.has(iterable, Symbol.iterator)\n      ) {\n        this.add(iterable)\n        continue\n      }\n\n      for (const element of iterable) {\n        this.add(element)\n      }\n    }\n  },\n\n  /**\n   * Checks to see if any value within the `Set` loosely equals the supplied\n   * value.\n   *\n   * @param {*} value any value that might be loosely equal to an item in the\n   * set, as opposed to {@link Set.has} which is the equivalent of a strict or\n   * triple equals (`===`) check\n   * @returns {boolean} `true` if any value within the set is loosely equal to\n   * the supplied value, `false` otherwise\n   */\n  contains(value) {\n    for (const element of this) {\n      if (value == element) {\n        return true\n      }\n    }\n\n    return false\n  },\n\n  /**\n   * Checks if every element in the set passes the test implemented by the\n   * provided function. The function is called with each element of the set.\n   * Note: Since sets do not have indices, the index parameter is always NaN.\n   *\n   * @param {Function} everyFn - The function to test each element. Receives\n   * the element, index (always NaN), and the set itself.\n   * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n   * `everyFn`.\n   * @throws {TypeError} If `everyFn` is not a function.\n   * @returns {boolean} True if every element passes the test, false otherwise.\n   */\n  every(everyFn, thisArg) {\n    if (typeof everyFn !== 'function') {\n      throw new TypeError(\n        `everyFn must be a function! Received ${String(everyFn)}`\n      )\n    }\n\n    let found = 0\n\n    for (const element of this) {\n      if (everyFn.call(thisArg, element, NaN, this)) {\n        found++\n      }\n    }\n\n    return (found === this.size)\n  },\n\n\n  /**\n   * Finds the first element in the set satisfying the provided testing\n   * function. If no elements satisfy the testing function, undefined is\n   * returned. The function is called with each element of the set.\n   * Note: Since sets do not have indices, the index parameter is always NaN.\n   *\n   * @param {Function} findFn - The function to execute on each element. It\n   * receives the element, index (always NaN), and the set itself.\n   * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n   * `findFn`.\n   * @throws {TypeError} If `findFn` is not a function.\n   * @returns {*} The first element that satisfies `findFn`, or undefined.\n   */\n  find(findFn, thisArg) {\n    if (typeof findFn !== 'function') {\n      throw new TypeError(\n        `findFn must be a function! Received ${String(findFn)}`\n      )\n    }\n\n    for (const element of this) {\n      const match = findFn.call(thisArg, element, NaN, this)\n      if (match) {\n        return element\n      }\n    }\n\n    return undefined\n  },\n\n  /**\n   * Finds the last element in the set satisfying the provided testing function.\n   * If no elements satisfy the testing function, undefined is returned. The\n   * function is called with each element of the set in reverse order.\n   * Note: Since sets do not have indices, the index parameter is always NaN.\n   *\n   * @param {Function} findFn - The function to execute on each element. It\n   * receives the element, index (always NaN), and the set itself.\n   * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n   * `findFn`.\n   * @throws {TypeError} If `findFn` is not a function.\n   * @returns {*} The last element that satisfies `findFn`, or undefined.\n   */\n  findLast(findFn, thisArg) {\n    if (typeof findFn !== 'function') {\n      throw new TypeError(\n        `findFn must be a function! Received ${String(findFn)}`\n      )\n    }\n\n    const found = []\n\n    for (const element of this) {\n      const match = findFn.call(thisArg, element, NaN, this)\n      if (match) {\n        found.push(element)\n      }\n    }\n\n    if (found.length) {\n      return found[found.length - 1]\n    }\n\n    return undefined\n  },\n\n  /**\n   * A getter property that returns the number of elements in the set.\n   * This is an alias for the `size` property of the set.\n   *\n   * @returns {number} The number of elements in the set.\n   */\n  get length() {\n    return this.size\n  },\n\n  /**\n   * Creates a new array populated with the results of calling the provided\n   * function on every element in the set. The function is called with each\n   * element of the set. Note: Since sets do not have indices, the index\n   * parameter is always NaN.\n   *\n   * @param {Function} mapFn - The function to execute on each element. It\n   * receives the element, index (always NaN), and the set itself.\n   * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n   * `mapFn`.\n   * @throws {TypeError} If `mapFn` is not a function.\n   * @returns {Array} A new array with each element being the result of the\n   * `mapFn`.\n   */\n  map(mapFn, thisArg) {\n    if (typeof mapFn !== 'function') {\n      throw new TypeError(\n        `mapFn must be a function! Received ${String(mapFn)}`\n      )\n    }\n\n    const transformed = []\n\n    for (const element of this) {\n      transformed.push(mapFn.call(thisArg, element, NaN, this))\n    }\n\n    return transformed\n  },\n\n  /**\n   * Applies a function against an accumulator and each element in the set to\n   * reduce it to a single value. The function is called with each element of\n   * the set. Note: Since sets do not have indices, the index parameter is\n   * always NaN.\n   *\n   * @param {Function} reduceFn - The function to execute on each element. It\n   * receives the accumulator, element, index (always NaN), and the set itself.\n   * @param {*} initialValue - The initial value to start reducing from.\n   * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n   * `reduceFn`.\n   * @throws {TypeError} If `reduceFn` is not a function.\n   * @returns {*} The reduced value.\n   */\n  reduce(reduceFn, initialValue, thisArg) {\n    if (typeof reduceFn !== 'function') {\n      throw new TypeError(\n        `reduceFn must be a Function! Received ${String(reduceFn)}`\n      )\n    }\n\n    let accumulator = initialValue\n    for (const element of this) {\n      accumulator = reduceFn.call(thisArg, accumulator, element, NaN, this)\n    }\n\n    return accumulator\n  },\n\n  /**\n   * Tests whether at least one element in the set passes the test implemented\n   * by the provided function. The function is called with each element of the\n   * set. Note: Since sets do not have indices, the index parameter is always NaN.\n   *\n   * @param {Function} someFn - The function to test each element. It receives\n   * the element, index (always NaN), and the set itself.\n   * @param {Object} [thisArg] - Optional. Value to use as `this` when executing\n   * `someFn`.\n   * @throws {TypeError} If `someFn` is not a function.\n   * @returns {boolean} True if at least one element passes the test, false\n   * otherwise.\n   */\n  some(someFn, thisArg) {\n    if (typeof someFn !== 'function') {\n      throw new TypeError(\n        `someFn must be a function! Received ${String(someFn)}`\n      )\n    }\n\n    for (const element of this) {\n      if (someFn.call(thisArg, element, NaN, this)) {\n        return true\n      }\n    }\n\n    return false\n  },\n})", "import { Patch } from '@nejs/extension'\nimport { ObjectExtensions } from './objectextensions.js'\n\nconst { isObject } = ObjectExtensions.patches\n\n/**\n * The `ReflectExtensions` class is a patch applied to the built-in JavaScript\n * `Reflect` object. It extends `Reflect` with additional utility methods that\n * enhance its capabilities. These methods provide more advanced ways of\n * interacting with object properties, such as checking for the presence of\n * multiple keys at once (`hasAll`) or verifying if at least one specified key\n * exists in an object (`hasSome`). This class is part of the `@nejs/extension`\n * library and is designed to offer these extended functionalities in a way\n * that is consistent with the existing `Reflect` API, making it intuitive for\n * developers who are already familiar with standard reflection methods in\n * JavaScript.\n */\nexport const ReflectExtensions = new Patch(Reflect, {\n  /**\n   * The function checks if an object has all the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to\n   * check if it has all the specified keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means\n   * it can accept any number of arguments. In this case, it is expected\n   * to receive multiple keys as arguments.\n   * @returns a boolean value.\n   */\n  hasAll(object, ...keys) {\n    return Object.isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .every(has => has)\n    )\n  },\n\n  /**\n   * Fetches all descriptors of an object, including those mapped to a\n   * symbol descriptor value.\n   *\n   * @param {object} object the object from whose descriptors need to be\n   * retrieved.\n   * @returns {object} with keys mapped to object descriptors\n   * @throws {TypeError} if the supplied `object` is null or not an object\n   * a TypeError exception will be thrown\n   */\n  ownDescriptors(object) {\n    if (!isObject(object)) {\n      throw new TypeError('The supplied object must be non-null and an object')\n    }\n\n    const result = {}\n\n    const keys = Reflect.ownKeys(object)\n\n    for (const key of keys) {\n      result[key] = Object.getOwnPropertyDescriptor(key)\n    }\n\n    return result\n  },\n\n  /**\n   * The function checks if an object has at least one of the specified keys.\n   *\n   * @param object - The `object` parameter is the object that we want to check\n   * for the presence of certain keys.\n   * @param keys - The `keys` parameter is a rest parameter, which means it can\n   * accept any number of arguments. These arguments are the keys that we want\n   * to check if they exist in the `object`.\n   * @returns The function `hasSome` returns a boolean value indicating whether\n   * at least one of the keys provided as arguments exists in the given object.\n   */\n  hasSome(object, ...keys) {\n    return isObject(object) && (keys.flat(Infinity)\n      .map(key => Reflect.has(object, key))\n      .some(has => has)\n    )\n  },\n\n  /**\n   * Retrieves an array of [key, descriptor] pairs for each property of the\n   * provided object. This method is akin to `Object.entries` but includes\n   * property descriptors instead of the property values. It's useful for cases\n   * where you need detailed information about properties, including their\n   * configurability, enumerability, and accessors.\n   *\n   * @param {object} object - The object whose property entries are to be\n   * retrieved.\n   * @returns {Array} An array of [key, descriptor] pairs, where each pair\n   * consists of the property name (key) and its descriptor. Returns an empty\n   * array if the input is not a valid object.\n   */\n  entries(object) {\n    if (!object || typeof object !== 'object') { return [] }\n\n    return Reflect.ownKeys(object).map(key => [\n      key, Object.getOwnPropertyDescriptor(object, key)\n    ])\n  },\n\n  /**\n   * Retrieves an array of values from the property descriptors of the given\n   * object. This method works similarly to `Object.values` but operates on\n   * property descriptors instead. It's useful when you need the values of\n   * properties including getters, setters, and other descriptor-specific\n   * attributes.\n   *\n   * @param {object} object - The object whose property values are to be\n   * retrieved.\n   * @returns {Array} An array of values extracted from the object's property\n   * descriptors. The values correspond to the `value` attribute in each\n   * property's descriptor. Returns an empty array if the input is not a valid\n   * object.\n   */\n  values(object) {\n    return Reflect.entries.map(([,value]) => value)\n  }\n})\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `StringExtensions` is a patch for the JavaScript built-in `String` class. It\n * adds utility methods to the `String` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `String` class with additional\n * utility functions.\n */\nexport const StringExtensions = new Patch(String, {\n  /**\n   * The `isString` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a string.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `String`, `false` otherwise\n   */\n  isString(value) {\n    if (value && (typeof value === 'string' || value instanceof String)) {\n      return value.length > 0\n    }\n    return false\n  },\n});\n", "import { Patch } from '@nejs/extension';\n\n/**\n * `SymbolExtensions` is a patch for the JavaScript built-in `Symbol` class. It\n * adds utility methods to the `Symbol` class without modifying the global namespace\n * directly. This patch includes methods for key validation, object type checking,\n * and retrieving the string tag of an object. These methods are useful for\n * enhancing the capabilities of the standard `Symbol` class with additional\n * utility functions.\n */\nexport const SymbolExtensions = new Patch(Symbol, {\n  /**\n   * The `isSymbol` method does exactly what one would it expect. It returns\n   * true if the string matches typeof or instanceof as a symbol.\n   *\n   * @param {*} value checks to see if the `value` is a string\n   * @returns {boolean} `true` if it is a `Symbol`, `false` otherwise\n   */\n  isSymbol(value) {\n    return value && (typeof value === 'symbol');\n  },\n\n  /**\n   * Returns true if the supplied value is a Symbol created using\n   * `Symbol.for()`.\n   *\n   * @param {any} value assumption is that the supplied value is of type\n   * 'symbol' however, unless `allowOnlySymbols` is set to `true`, `false`\n   * will be returned for any non-symbol values.\n   * @param {boolean} allowOnlySymbols true if an error should be thrown\n   * if the supplied value is not of type 'symbol'\n   * @returns true if the symbol is registered, meaning, none of the spec\n   * static symbols (`toStringTag`, `iterator`, etc...), and no symbols\n   * created by passing a value directly to the Symbol function, such as\n   * `Symbol('name')`\n   */\n  isRegistered(value, allowOnlySymbols = false) {\n    if (!Symbol.isSymbol(value)) {\n      if (allowOnlySymbols) {\n        throw new TypeError('allowOnlySymbols specified; value is not a symbol')\n      }\n      return false\n    }\n\n    return Symbol.keyFor(value) !== undefined\n  },\n\n  /**\n   * A function that returns true if the symbol is not registered, meaning,\n   * any of the spec static symbols (`toStringTag`, `iterator`, etc...), and\n   * any symbols created by passing a value directly to the `Symbol` function,\n   * such as `Symbol('name')`.\n   *\n   * @param {any} value assumption is that the supplied value is of type\n   * 'symbol' however, unless allowOnlySymbols is set to true, false will\n   * be returned for any non-symbol values.\n   * @param {boolean} allowOnlySymbols true if an error should be thrown\n   * if the supplied value is not of type 'symbol'\n   * @returns true if the symbol is not registered, meaning, any of the\n   * spec static symbols (`toStringTag`, `iterator`, etc...), and any symbols\n   * created by passing a value directly to the `Symbol` function, such as\n   * `Symbol('name')`\n   * @returns true if the `value` in question is both a `symbol` and has\n   * returns `undefined` if passed to `Symbol.keyFor`\n   */\n  isNonRegistered(value, allowOnlySymbols = false) {\n    return !Symbol.isRegistered(value, allowOnlySymbols)\n  },\n});\n", "import { Patch } from '@nejs/extension'\n\n/**\n * The `ArrayPrototypeExtensions` patch extends the prototype of the built-in\n * JavaScript `Array` with additional properties for convenience and improved\n * readability. By applying this patch, all array instances gain new getter\n * properties `first` and `last`, which provide quick access to the first and\n * last elements of the array, respectively. This enhancement simplifies common\n * operations on arrays and makes code more expressive and concise.\n */\nexport const ArrayPrototypeExtensions = new Patch(Array.prototype, {\n  /**\n   * Sometimes defining even a short function for the invocation of `find`\n   * can be troublesome. This helper function performs that job for you. If\n   * the specified element is in the array, `true` will be returned.\n   *\n   * @param {*} value the value to search for. This value must triple equals\n   * the array element in order to return true.\n   * @returns true if the exact element exists in the array, false otherwise\n   */\n  contains(value) {\n    return !!this.find(entry => entry === value)\n  },\n\n  /**\n   * The `findEntry` function searches the entries of the object and returns\n   * the `[index, value]` entry array for the first matching value found.\n   *\n   * @param {function} findFn a function that takes the element to be checked\n   * and returns a boolean value\n   * @returns if `findFn` returns `true`, an array with two elements, the first\n   * being the index, the second being the value, is returned.\n   */\n  findEntry(findFn) {\n    const entries = this.entries()\n    const VALUE = 1\n\n    for (let entry of entries) {\n      if (findFn(entry[VALUE])) {\n        return entry\n      }\n    }\n\n    return undefined\n  },\n\n  /**\n   * A getter property that returns the first element of the array. If the\n   * array is empty, it returns `undefined`. This property is useful for\n   * scenarios where you need to quickly access the first item of an array\n   * without the need for additional checks or method calls.\n   *\n   * @returns {*} The first element of the array or `undefined` if the array\n   * is empty.\n   */\n  get first() {\n    return this[0];\n  },\n\n  /**\n   * A getter property that returns the last element of the array. It\n   * calculates the last index based on the array's length. If the array is\n   * empty, it returns `undefined`. This property is beneficial when you need\n   * to access the last item in an array, improving code readability and\n   * avoiding manual index calculation.\n   *\n   * @returns {*} The last element of the array or `undefined` if the\n   * array is empty.\n   */\n  get last() {\n    return this[this.length - 1];\n  },\n\n})", "import { Extension } from '@nejs/extension'\nimport { ObjectExtensions } from '../objectextensions.js'\nimport { ReflectExtensions } from '../reflectextensions.js'\n\nconst { isObject, isValidKey } = ObjectExtensions.patches\nconst { hasSome } = ReflectExtensions.patches\n\nexport class Descriptor {\n  /**\n   * The default private descriptor value is that of `enigmatic`\n   *\n   * @private\n   * @type {object}\n   */\n  #desc = undefined\n\n  /**\n   * An optionally associated object, usually the parent from which\n   * the descriptor was taken, or undefined if none was able to be\n   * derived.\n   *\n   * @type {object}\n   */\n  #object = undefined\n\n  /**\n   * Constructs a Descriptor instance which wraps and manages an object\n   * property descriptor. The constructor can handle an existing descriptor\n   * object or create a new one based on an object and a property key.\n   *\n   * @param {object|Descriptor} object - The target object or an existing\n   * Descriptor instance. If it's an object, it is used in conjunction with\n   * `key` to create a descriptor. If it's a Descriptor instance, it is used\n   * directly as the descriptor.\n   * @param {string|symbol} [key] - The property key for which the descriptor\n   * is to be created. This parameter is ignored if `object` is a Descriptor\n   * instance. If `key` is an object and `object` is a valid descriptor, `key`\n   * is treated as the associated object.\n   * @throws {Error} Throws an error if the constructed descriptor is not \n   * valid.\n   */\n  constructor(object, key) {\n    if ((object ?? key) === undefined) {\n      this.#desc = Descriptor.enigmatic\n    }\n    else if (Descriptor.isDescriptor(object)) {\n      this.#desc = object\n      this.#object = isObject(key) ? key : undefined\n    } \n    else if (isObject(object) && isValidKey(key)) {\n      this.#desc = Object.getOwnPropertyDescriptor(object, key)\n      this.#object = object\n    }\n\n    if (!this.isDescriptor) {\n      console.error(`\n      Descriptor(object,key) FAILED:\n        object:      ${object === globalThis ? '[GLOBAL]' : (typeof key === 'object' ? JSON.stringify(object) : String(object))}\n        key:         ${key === globalThis ? '[GLOBAL]' : (typeof key === 'object' ? JSON.stringify(key) : String(key))}\n        descriptor:  `, this.#desc\n      )\n      throw new Error(`Not a valid descriptor:`, this.#desc)\n    }\n  }\n\n  /**\n   * Detects whether or not this instance is an accessor object descriptor\n   *\n   * @returns {boolean} true if this object has a getter or setter and is not\n   * a data descriptor\n   */\n  get isAccessor() {\n    return Descriptor.isAccessor(this.#desc)\n  }\n\n  /**\n   * Detects whether or not this instance is an data object descriptor\n   *\n   * @returns {boolean} true if this object has a value property and is not\n   * an accessor descriptor\n   */\n  get isData() {\n    return Descriptor.isData(this.#desc)\n  }\n\n  /**\n   * Detects whether or not this instance is a valid object descriptor\n   *\n   * @returns {boolean} true if this descriptor store is a valid descriptor\n   */\n  get isDescriptor() {\n    return Descriptor.isDescriptor(this.#desc)\n  }\n\n  /**\n   * Getter around the `configurable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get configurable() {\n    return !!this.#desc?.configurable\n  }\n\n  /**\n   * Sets the `configurable` value of this object. If the internal descriptor\n   * store store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `configurable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set configurable(value) {\n    (this.#desc || {}).configurable = !!value\n  }\n\n  /**\n   * Getter around the `enumerable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get enumerable() {\n    return this.#desc?.enumerable\n  }\n\n  /**\n   * Sets the `enumerable` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `enumerable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set enumerable(value) {\n    (this.#desc || {}).enumerable = value\n  }\n\n  /**\n   * Getter around the `writable` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {boolean} a boolean value or undefined if the internal\n   * descriptor store is invalid.\n   */\n  get writable() {\n    return this.#desc?.writable\n  }\n\n  /**\n   * Sets the `writable` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {boolean} value the value to set for the `writable` descriptor\n   * property. If this value is not a `boolean` it will be converted to one\n   */\n  set writable(value) {\n    (this.#desc || {}).writable = value\n  }\n\n  /**\n   * Getter around the `value` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {any} any value stored in this descriptor\n   */\n  get value() {\n    return this.#desc?.value\n  }\n\n  /**\n   * Sets the `value` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {any} value the value to set for the `value` descriptor\n   * property.\n   */\n  set value(value) {\n    (this.#desc || {}).value = value\n  }\n\n  /**\n   * Getter around the `get` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {function} a function if the getter for this descriptor is\n   * defined or `undefined` if the internal descriptor object or the getter\n   * is undefined.\n   */\n  get get() {\n    return this.#desc?.get\n  }\n\n  /**\n   * Retrieves the {@link get} function for this accessor and binds it to\n   * the object from which the descriptor was derived, if that value is set.\n   * Otherwise this method is identical to the {@link get} accessor.\n   *\n   * @returns {function} the getter if one is defined. If possible this\n   * getter will be bound the associated and previously set `object`.\n   */\n  get boundGet() {\n    return (isObject(this.#object) ? this.get?.bind(this.#object) : this.get)\n  }\n\n  /**\n   * Sets the `get` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {function} value the getter function for this descriptor\n   */\n  set get(value) {\n    (this.#desc || {}).get = value\n  }\n\n  /**\n   * Getter around the `set` object descriptor property of\n   * this instance of Descriptor.\n   *\n   * @returns {function} a function if the setter for this descriptor is\n   * defined or `undefined` if the internal descriptor object or the setter\n   * is undefined.\n   */\n  get set() {\n    return (this.#desc || {}).set\n  }\n\n  /**\n   * Retrieves the {@link set} function for this accessor and binds it to\n   * the object from which the descriptor was derived, if that value is set.\n   * Otherwise this method is identical to the {@link set} accessor.\n   *\n   * @returns {function} the setter if one is defined. If possible this\n   * setter will be bound the associated and previously set `object`.\n   */\n  get boundSet() {\n    return (isObject(this.#object) ? this.set?.bind(this.#object) : this.set)\n  }\n\n  /**\n   * Sets the `set` value of this object. If the internal descriptor\n   * store is invalid, the value is thrown away\n   *\n   * @param {function} value the setter function for this descriptor\n   */\n  set set(value) {\n    (this.#desc || {}).set = value\n  }\n\n  /**\n   * The function checks the descriptor's associated object has been set on this\n   * instance of `Descriptor`.\n   *\n   * @returns {boolean} `true` if the `object` property has been set,\n   * `false` otherwise\n   */\n  get hasObject() { return isObject(this.#object) }\n\n  /**\n   * Returns the descriptor's associated `object` value. This is usually the\n   * parent object from which the descriptor was derived. If the value is preset\n   * it will be returned. Undefined will be returned otherwise\n   *\n   * @returns {object} the associated object for this descriptor or undefined\n   * if it has not yet been set.\n   */\n  get object() { return this.#object }\n\n  /**\n   * Sets the descriptor's associated `object` value. This is usually the\n   * parent object from which the descriptor was derived.\n   *\n   * @param {object} value sets the object for which this descriptor is to\n   * be associated with.\n   */\n  set object(value) { this.#object = Object(value) }\n\n  /**\n   * The function returns a string representation of a descriptor object with\n   * additional information about its type when used in the NodeJS repl.\n   *\n   * @param {number} depth - The `depth` parameter is used to specify the\n   * maximum depth to which nested objects and arrays will be formatted. If\n   * the depth is exceeded, the output will be truncated with ellipses.\n   * @param {object} options - The `options` parameter is an object that\n   * contains various configuration options for the `inspect` function.\n   * These options can be used to customize the output of the inspection.\n   * @param {function} inspect - The `inspect` parameter is a function that\n   * is used to convert an object into a string representation. It is\n   * typically used for debugging purposes or when displaying an object's\n   * properties.\n   * @returns a string that represents a descriptor. The string includes the\n   * type of the descriptor (either \"Accessor\" or \"Data\") and the result of\n   * inspecting the descriptor object using the provided options and depth.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const type = this.isAccessor ? ' (Accessor)' : this.isData ? ' (Data)' : ''\n    return `Descriptor${type} ${inspect(this.#desc, {...options, depth})}`\n  }\n\n  /**\n   * Shorthand for Object.getOwnPropertyDescriptor()\n   *\n   * @param {object} object a non-null object instance\n   * @param {string|symbol} key a symbol or string referencing which key on the\n   * object to return a descriptor for.\n   * @returns an object descriptor for the requested field or null\n   */\n  static for(object, key, wrap = false) {\n    if (!isObject(object) || !isValidKey(key) || !Reflect.has(object, key)) {\n      return null\n    }\n\n    return (wrap\n      ? new Descriptor(Object.getOwnPropertyDescriptor(object, key))\n      : Object.getOwnPropertyDescriptor(object, key)\n    )\n  }\n\n  /**\n   * Take the descriptor defined by this objects values and apply them to\n   * the specified object using the specified key.\n   *\n   * @param {object} object the object to apply this descriptor to\n   * @param {string|symbol} forKey the string or symbol for which this\n   * descriptor will abe applied\n   */\n  applyTo(object, forKey, bindAccessors = false) {\n    if (!isObject(object) || !isValidKey(forKey)) {\n      throw new Error(`Cannot apply descriptor to non-object or invalid key`)\n    }\n\n    return Object.defineProperty(object, forKey, this.toObject(bindAccessors))\n  }\n\n  /**\n   * Converts this Descriptor class instance into a basic object descriptor\n   * that is accepted by all the standard JavaScript runtime methods that\n   * deal with object descriptors.\n   * \n   * @param {boolean|object} bindAccessors if `true`, a non-fatal attempt to\n   * bind accessor getter and setter methods is made before returning the\n   * object. If `bindAccessors` is truthy and is also an object, this is the\n   * object the accessors will be bound to. If the value is falsy or if the\n   * descriptor instance represents a data descriptor, nothing happens.\n   * @returns {object} the object instance's basic object representation as\n   * a descriptor.\n   */\n  toObject(bindAccessors = false) {\n    let descriptor = { ...this.#desc }\n\n    if (bindAccessors && this.isAccessor) {\n      if (this.hasObject) {\n        descriptor = { \n          ...descriptor, \n          get: this.boundGet,\n          set: this.boundSet\n        }\n      }\n      else if (isObject(bindAccessors)) {\n        descriptor = {\n          ...descriptor,\n          get: this.get?.bind(bindAccessors),\n          set: this.set?.bind(bindAccessors)\n        }\n      }\n    }\n\n    return descriptor\n  }\n\n  /**\n   * Converts this descriptor object into a base representation\n   *\n   * @param {string} hint one of `string`, `number` or default;\n   * @returns if the hint is 'string', then a string identifying the enum\n   * and its type is returned. `number` will always be NaN since it is incoret\n   */\n  [Symbol.toPrimitive](hint) {\n    switch (hint) {\n      case 'string':\n        if (this.isAccessor) {\n          const hasGetter = Reflect.has(this.#desc, 'get') ? `getter` : ''\n          const hasSetter = Reflect.has(this.#desc, 'set') ? `setter` : ''\n          const separator = hasGetter && hasSetter ? ', ' : ''\n\n          return `Accessor (${hasGetter}${separator}${hasSetter})`\n        }\n        else if (this.isData) {\n          const hasGetter = Reflect.has(this.#desc, 'value') ? `value` : ''\n          const hasSetter = Reflect.has(this.#desc, 'writable') ? `writable` : ''\n          const separator = hasGetter && hasSetter ? ', ' : ''\n\n          return `Data (${hasGetter}${separator}${hasSetter})`\n        }\n        break\n\n      case 'number':\n        return NaN\n\n      default:\n        return this.toObject()\n    }\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * The function `getData` retrieves the value of a property from an object\n   * if it exists and is a data property.\n   *\n   * @param {object} object - The \"object\" parameter is the object from which\n   * we want to retrieve data.\n   * @param {string|symbol} property - The `property` parameter is the name of\n   * the property that you want to retrieve the data from.\n   * @returns either the value of the specified property if it exists and is\n   * a data property, or undefined if the property does not exist or is not\n   * a data property.\n   */\n  static getData(object, property) {\n    if (!isObject(object) || !Reflect.has(object, property)) {\n      return undefined;\n    }\n\n    const descriptor = Descriptor.for(object, property, true)\n    if (!descriptor.isData) {\n      return null\n    }\n\n    return descriptor.value\n  }\n\n  /**\n   * The function `getAccessor` checks if an object has a getter/setter accessor\n   * for a given property and returns the accessor functions if found.\n   *\n   * @param object - The `object` parameter is the object from which we want to\n   * retrieve the accessor for a specific property.\n   * @param property - The `property` parameter is the name of the property for\n   * which we want to get the accessor.\n   * @returns an object that contains the getter and setter functions for the\n   * specified property of the given object. If the property is an accessor\n   * property (defined with a getter and/or setter), the returned object will\n   * also have additional properties such as \"accessor\" and \"descriptor\". If\n   * the property is not found or is not an accessor property, the function\n   * returns undefined.\n   */\n  static getAccessor(object, property) {\n    if (!isObject(object) || !Reflect.has(object, property)) {\n      return undefined;\n    }\n\n    const descriptor = Descriptor.for(object, property, true)\n    if (!descriptor.isAccessor) {\n      return null\n    }\n\n    return descriptor.get.bind(object)()\n  }\n\n  /**\n   * The function returns an object with enumerable and configurable properties\n   * based on the input parameters.\n   *\n   * @param [enumerable=false] - A boolean value indicating whether the property\n   * can be enumerated (listed) when iterating over the object's properties.\n   * @param [configurable=false] - The `configurable` parameter determines\n   * whether the property can be deleted or its attributes can be modified.\n   * If `configurable` is set to `true`, the property can be deleted and its\n   * attributes can be changed. If `configurable` is set to `false`, the\n   * property cannot be deleted and\n   * @returns An object with the properties `enumerable` and `configurable` is\n   * being returned. The values of these properties are determined by the\n   * arguments passed to the `base` function.\n   */\n  static base(enumerable = false, configurable = false) {\n    return {\n      enumerable,\n      configurable\n    }\n  }\n\n  /**\n   * The function \"newAccessor\" creates a new property descriptor object with a\n   * getter and setter function, along with optional enumerable and configurable\n   * flags.\n   *\n   * @param getter - The getter parameter is a function that will be used as the\n   * getter for the property. It will be called when the property is accessed.\n   * @param setter - The `setter` parameter is a function that will be used as\n   * the setter for the property. It will be called whenever the property is\n   * assigned a new value.\n   * @param [] - - `getter`: A function that will be used as the getter for the\n   * property.\n   * @returns an object with properties \"get\", \"set\", \"enumerable\", and\n   * \"configurable\".\n   */\n  static accessor(\n    getter,\n    setter,\n    { enumerable, configurable } = Descriptor.base()\n  ) {\n    return {\n      get: getter,\n      set: setter,\n      enumerable,\n      configurable\n    }\n  }\n\n  /**\n   * The function \"newData\" creates a new data object with customizable\n   * properties.\n   *\n   * @param value - The value parameter represents the value that will be\n   * assigned to the property.\n   * @param [writable=true] - The `writable` parameter determines whether the\n   * value of the property can be changed. If `writable` is set to `true`, the\n   * value can be changed. If `writable` is set to `false`, the value cannot be\n   * changed.\n   * @param [] - - `value`: The value to be assigned to the property.\n   * @returns an object with properties `value`, `enumerable`, `writable`, and\n   * `configurable`.\n   */\n  static data(\n    value,\n    writable = true,\n    { enumerable, configurable } = Descriptor.base()\n  ) {\n    return {\n      value,\n      enumerable,\n      writable,\n      configurable\n    }\n  }\n\n  /**\n   * The function checks if an object is a likely an object descriptor in\n   * JavaScript. This is determined as an object with some of the known\n   * descriptor keys (e.g. enumerable, configurable, value, writable, get,\n   * or set). Technically, any object could serve as a descriptor but this\n   * function only returns true if known descriptor keys are found.\n   *\n   * @param object - The `object` parameter is the object that we want to\n   * check if it is a descriptor.\n   * @returns a boolean value.\n   */\n  static isDescriptor(object) {\n    const knownKeys = [\n      ...Descriptor.SHARED_KEYS,\n      ...Descriptor.ACCESSOR_KEYS,\n      ...Descriptor.DATA_KEYS,\n    ]\n\n    return hasSome(object, knownKeys)\n  }\n\n  /**\n   * The function checks if a given property or descriptor is a data property.\n   *\n   * brie\n   *\n   * @param descriptor_orProp - The `descriptor_orProp` parameter can be\n   * either a descriptor or a property name.\n   * @param object - The `object` parameter is the object that you want to\n   * check for data properties.\n   * @returns a boolean value. It returns `true` if the `descriptor` object\n   * has any keys that match the `DATA_KEYS` array, otherwise it returns\n   * `false`.\n   */\n  static isData(object_orProp, property) {\n    const needsDescriptor = (\n      ((typeof object_orProp === 'object') || object_orProp instanceof Object) &&\n      property instanceof String\n    )\n\n    const descriptor = (needsDescriptor\n      ? Descriptor.for(object_orProp, property)\n      : object_orProp\n    )\n\n    const { DATA_KEYS } = this\n    let validData = false\n\n    if (hasSome(descriptor, DATA_KEYS)) {\n      validData = true\n    }\n\n    return validData\n  }\n\n  /**\n   * The function checks if a given property descriptor or property of an\n   * object is an accessor.\n   *\n   * @param object_orProp - The `descriptor_orProp` parameter can be either a\n   * descriptor object or a property name.\n   * @param property - The `object` parameter is the object that you want to\n   * check for accessor properties.\n   * @returns a boolean value. It returns true if the descriptor or property\n   * passed as an argument is an accessor descriptor, and false otherwise.\n   */\n  static isAccessor(object_orProp, property) {\n    const needsDescriptor = (\n      (object_orProp && property) &&\n      ((typeof object_orProp === 'object') || object_orProp instanceof Object) &&\n      (property instanceof String || (typeof property === 'symbol'))\n    )\n\n    const descriptor = (needsDescriptor\n      ? Descriptor.for(object_orProp, property)\n      : object_orProp)\n\n    const { ACCESSOR_KEYS } = this\n    let validAccessor = false\n\n    if (hasSome(descriptor, ACCESSOR_KEYS)) {\n      validAccessor = true\n    }\n\n    return validAccessor\n  }\n\n  /**\n   * A base descriptor (new for each read) that is both enumerable and\n   * configurable\n   *\n   * @returns The method `flexible` is returning the result of calling the\n   * `base` method with the arguments `true` and `true`.\n   */\n  static get flexible() {\n    return this.base(true, true)\n  }\n\n  /**\n   * A base descriptor (new for each read) that is not enumerable but is\n   * configurable\n   *\n   * @returns The method `enigmatic` is returning the result of calling\n   * the `base` method with the arguments `false` and `true`.\n   */\n  static get enigmatic() {\n    return this.base(false, true)\n  }\n\n  /**\n   * A base descriptor (new for each read) that is neither enumerable\n   * nor configurable\n   *\n   * @returns The code is returning the result of calling the `base` method with\n   * the arguments `false` and `false`.\n   */\n  static get intrinsic() {\n    return this.base(false, false)\n  }\n\n  /**\n   * A base descriptor (new for each read) that enumerable but not configurable\n   *\n   * @returns The method is returning the result of calling the `base`\n   * method with the arguments `true` and `false`.\n   */\n  static get transparent() {\n    return this.base(true, false)\n  }\n\n  /**\n   * The function returns an array of shared descriptor keys.\n   *\n   * @returns An array containing the strings 'configurable' and 'enumerable'.\n   */\n  static get SHARED_KEYS() {\n    return ['configurable', 'enumerable']\n  }\n\n  /**\n   * The function returns an array of accessor descriptor keys.\n   *\n   * @returns An array containing the strings 'get' and 'set' is being returned.\n   */\n  static get ACCESSOR_KEYS() {\n    return ['get', 'set']\n  }\n\n  /**\n   * The function returns an array of data descriptor keys.\n   *\n   * @returns An array containing the strings 'value' and 'writable' is being\n   * returned.\n   */\n  static get DATA_KEYS() {\n    return ['value', 'writable']\n  }\n}\n\nexport const DescriptorExtensions = new Extension(Descriptor)", "import { Patch } from '@nejs/extension'\nimport { FunctionExtensions } from './functionextensions.js'\n\nconst { isClass, isFunction } = FunctionExtensions.patches\nconst CustomInspect = Symbol.for('nodejs.util.inspect.custom')\n\nexport const GlobalFunctionsAndProps = new Patch(globalThis, {\n  /**\n   * Transforms an object to mimic a specified prototype, altering its type\n   * conversion and inspection behaviors. This function is especially useful\n   * for creating objects that need to behave like different primitive types\n   * under various operations.\n   *\n   * @param {Object} object - The object to be transformed.\n   * @param {Function|Object} [prototype=String.prototype] - The prototype or\n   * class to emulate. If a function is provided, its prototype is used.\n   * Defaults to String.prototype.\n   * @param {Function} [toPrimitive=(hint, val) => String(val)] - A function\n   * defining how the object should be converted to a primitive value. It\n   * receives a type hint ('number', 'string', or 'default') and the object,\n   * returning the primitive value.\n   * @returns {Object|null} The transformed object, or null if neither a class\n   * nor a prototype could be derived from the provided prototype parameter.\n   */\n  maskAs(object, classPrototype, options) {\n    const {\n      prototype,\n      toPrimitive\n    } = GenericMask({...options, prototype: classPrototype})\n\n    const base = { configurable: true, enumerable: false }\n    const proto = isFunction(prototype) ? prototype.prototype : prototype\n    const klass = isClass(prototype) ? prototype : proto?.constructor\n\n    if (!klass && !proto) {\n      return null\n    }\n\n    Object.setPrototypeOf(object, proto)\n    Object.defineProperties(object, {\n      valueOf: {\n        value() { return String(toPrimitive('default', object)) }, ...base },\n\n      [Symbol.toPrimitive]: {\n        value(hint) { return toPrimitive(hint, object) }, ...base\n      },\n      [Symbol.toStringTag]: { value: klass.name, ...base },\n      [Symbol.species]: { get() { return klass }, ...base },\n      [CustomInspect]: { ...base, value(depth, opts, inspect) {\n        return inspect(this[Symbol.toPrimitive](), { ...opts, depth })\n      }}\n    })\n\n    return object\n  },\n\n  /**\n   * Masks an object as a string-like object by setting its prototype to\n   * String and defining how it converts to primitive types. This is\n   * particularly useful when an object needs to behave like a string in\n   * certain contexts, such as type coercion or logging.\n   *\n   * @param {Object} object - The object to be masked as a string.\n   * @param {string} [stringKey='value'] - The object property key used for\n   * the string representation. Defaults to 'value'.\n   * @param {Function} [toPrimitive] - Optional custom function for primitive\n   * conversion. If omitted, a default function handling various conversion\n   * hints is used.\n   * @returns {Object|null} The string-masked object, or null if the object\n   * doesn't have the specified stringKey property.\n   */\n  maskAsString(\n    object,\n    stringKey,\n    toPrimitive\n  ) {\n    if (object && Reflect.has(object, stringKey)) {\n      return maskAs(object, StringMask(stringKey ?? 'value', toPrimitive))\n    }\n\n    return null\n  },\n\n  /**\n   * Masks an object as a number-like object. This allows the object to\n   * behave like a number in operations like arithmetic and type coercion.\n   * It sets the prototype to Number and defines custom conversion behavior.\n   *\n   * @param {Object} object - The object to be masked as a number\n   * representation. Defaults to 'value'.\n   * @param {Function} [toPrimitive] - Optional custom function for primitive\n   * conversion. If not provided, a default function handling different\n   * conversion hints is used.\n   * @returns {Object|null} The number-masked object, or null if the object\n   * doesn't have the specified numberKey property.\n   */\n  maskAsNumber(\n    object,\n    numberKey,\n    toPrimitive\n  ) {\n    if (object && Reflect.has(object, numberKey)) {\n      return maskAs(object, NumberMask(numberKey ?? 'value', toPrimitive))\n    }\n\n    return null\n  },\n\n  /**\n   * Generates options for generic masking of an object, providing defaults for\n   * prototype and toPrimitive function if not specified.\n   *\n   * @param {Object} options - The options object including prototype,\n   * targetKey, and toPrimitive function.\n   * @returns {Object} The options object with defaults applied as necessary.\n   */\n  GenericMask({ prototype, targetKey = 'value', toPrimitive }) {\n    const options = { targetKey, toPrimitive, prototype };\n\n    if (!isFunction(toPrimitive)) {\n      options.toPrimitive = (hint, object) => {\n        let property = object[targetKey];\n        let isNum = (\n          (typeof property === 'number' && Number.isFinite(property)) ||\n          (typeof property === 'string' &&\n            !isNaN(parseFloat(property)) && isFinite(property)\n          )\n        );\n\n        switch (hint) {\n          case 'string':\n            return isNum ? String(property) : (property ?? String(object));\n          case 'number':\n            return isNum ? Number(property) : NaN;\n          case 'default':\n          default:\n            return isNum ? Number(property) : property;\n        }\n      }\n    }\n\n    return options;\n  },\n\n  /**\n   * Generates options for string masking of an object, providing a default\n   * toPrimitive function if not specified.\n   *\n   * @param {string} targetKey - The object property key for string\n   * representation.\n   * @param {Function} toPrimitive - Custom function for primitive conversion.\n   * @returns {Object} Options for string masking.\n   */\n  StringMask(targetKey, toPrimitive) {\n    const options = { targetKey, toPrimitive, prototype: String.prototype }\n\n    if (!isFunction(toPrimitive)) {\n      options.toPrimitive = function toPrimitive(hint, object) {\n        switch (hint) {\n          case 'default': return object[targetKey]\n          case 'number': return parseInt(object[targetKey], 36)\n          case 'string': return String(object[targetKey])\n          default: return object\n        }\n      }\n    }\n\n    return options\n  },\n\n  /**\n   * Generates options for number masking of an object, providing a default\n   * toPrimitive function if not specified.\n   *\n   * @param {string} targetKey - The object property key for number\n   * representation.\n   * @param {Function} toPrimitive - Custom function for primitive conversion.\n   * @returns {Object} Options for number masking.\n   */\n  NumberMask(targetKey, toPrimitive) {\n    const options = { targetKey, toPrimitive, prototype: Number.prototype }\n\n    if (!isFunction(toPrimitive)) {\n      options.toPrimitive = function toPrimitive(hint, object) {\n        switch (hint) {\n          case 'default': return object[targetKey]\n          case 'number': return Number(object[targetKey])\n          case 'string': return String(object[targetKey])\n          default: return object\n        }\n      }\n    }\n\n    return options\n  },\n})\n", "import { Extension } from '@nejs/extension'\n\n/**\n * RefSet class extends the standard Set object to manage a collection of\n * WeakRef objects. It provides additional functionality such as objectification\n * of values and various utility methods.\n *\n * Unlike standard Sets or Arrays, RefSet stores weak references to objects,\n * allowing them to be garbage-collected if there are no other references to\n * them. This behavior is different from Arrays and standard Sets, which\n * maintain strong references to their elements.\n *\n * @extends Set\n */\nexport class RefSet extends Set {\n  /**\n   * Private field to track whether the RefSet should objectify primitive\n   * values.\n   *\n   * @private\n   */\n  #objectifyValues = false\n\n  /**\n   * Method to control whether the RefSet should objectify its values. When\n   * objectifying, primitive values (number, string, boolean, bigint) are\n   * converted to their respective object types, which allows them to be used as\n   * WeakRef targets.\n   *\n   * @param {boolean} setObjectification - Flag to enable or disable\n   * objectification.\n   * @returns {RefSet} - The current RefSet instance to allow method chaining.\n   */\n  objectifying(setObjectification = true) {\n    this.objectifyValues = setObjectification\n    return this\n  }\n\n  /**\n   * Returns the state indicating whether or not `RefSet` will attempt to\n   * convert non-valid primitives into targets that are valid input for\n   * new `WeakRef` object instances. If this value is `false` then no\n   * *objectification* will occur.\n   *\n   * @returns {boolean} The current state of objectifyValues.\n   */\n  get objectifyValues() {\n    return this.#objectifyValues\n  }\n\n  /**\n   * Setting this value to true, will cause all added values to the Set to\n   * be analyzed for validity as a candidate to be wrapped in a `WeakRef`\n   * object. If true, and if possible, the object will be turned into an\n   * `Object` variant first. This will also enable less rigid variable\n   * comparison in the `.has()` method (i.e. `==` instead of `===`).\n   *\n   * @param {boolean} value - The new state to set for objectifyValues.\n   */\n  set objectifyValues(value) {\n    this.#objectifyValues = !!value\n  }\n\n  /**\n   * Overrides the add method of Set. Adds a value to the RefSet, converting it\n   * to a WeakRef. Throws an error if the value is not a valid WeakRef target\n   * (e.g., null, undefined, or a registered symbol). If `objectifyValues` is\n   * enabled, an attempt to convert primitives to their object variants will be\n   * made. These are numbers, strings, boolean values and big integers.\n   *\n   * @param {*} value - The value to be added to the RefSet.\n   * @throws {TypeError} If the value is not a valid WeakRef target.\n   */\n  add(value) {\n    // Objectify the value if needed\n    if (this.#objectifyValues && (\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      typeof value === 'boolean' ||\n      typeof value === 'bigint'\n    )) {\n      value = Object(value);\n    }\n\n    // Check if the value is an object, and if it's a symbol, ensure it's not registered\n    if (typeof value === 'symbol' && Symbol.keyFor(value) !== undefined) {\n      throw new TypeError('RefSet cannot accept registered symbols as values');\n    }\n\n    if (typeof value !== 'object' && typeof value !== 'symbol') {\n      throw new TypeError(\n        'RefSet values must be objects, non-registered symbols, or objectified primitives'\n      );\n    }\n\n    // If the value is null or undefined, throw an error\n    if (value === null || value === undefined) {\n      throw new TypeError('RefSet values cannot be null or undefined');\n    }\n\n    super.add(new WeakRef(value));\n  }\n\n  /**\n   * Adds multiple values to the RefSet. The supplied `values` should be\n   * iterable and truthy. This function defers to `.add()` for its logic so\n   * each value from the supplied collection of values will also be subject\n   * to the criteria of that function.\n   *\n   * @param {Iterable} values - An iterable of values to add to the RefSet.\n   * @throws {TypeError} If the supplied values are falsey or non-iterable.\n   */\n  addAll(values) {\n    if (\n      !values ||\n      (typeof values !== 'object') ||\n      !Reflect.has(values, Symbol.iterator)\n    ) {\n      throw new TypeError('The supplied values are either falsey or non-iterable')\n    }\n\n    for (const value of values) {\n      this.add(value)\n    }\n  }\n\n  /**\n   * Removes all elements from the RefSet that have been garbage collected\n   * (i.e., their WeakRef no longer points to an object).\n   *\n   * @returns {RefSet} - The current RefSet instance to allow method chaining.\n   */\n  clean() {\n    for (const ref of this) {\n      if (!ref.deref()) {\n        this.delete(ref)\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Executes a provided function once for each value in the RefSet. The callback\n   * function receives the dereferenced value, the value again (as RefSet doesn't\n   * use keys), and the RefSet itself. This method provides a way to iterate over\n   * and apply operations to the values stored in the RefSet, taking into account\n   * that they are weak references and may have been garbage-collected.\n   *\n   * @param {Function} forEachFn - Function to execute for each element. It\n   * takes three arguments: element, element (again, as RefSet has no key), and\n   * the RefSet itself.\n   * @param {*} thisArg - Value to use as `this` when executing `forEachFn`.\n   */\n  entries() {\n    const refEntries = Array.from(super.entries())\n\n    return refEntries\n      .map(([_, ref]) => [ref.deref(), ref.deref()])\n      .filter(([_, value]) => !!value)\n  }\n\n  /**\n   * Iterate over the items in the set and pass them to the supplied\n   * function ala `Array.prototype.forEach`. Note however, there are no\n   * indexes on Sets and as such, the index parameter of the callback\n   * will always be `NaN`. Subsequently the `array` or third parameter\n   * will receive the set instance rather than an array.\n   *\n   * @param {function} forEachFn the function to use for each element in\n   * the set.\n   * @param {object} thisArg the `this` argument to be applied to each\n   * invocation of the `forEachFn` callback. Note, this value is unable\n   * to be applied if the `forEachFn` is a big arrow function\n   */\n  forEach(forEachFn, thisArg) {\n    const set = this\n\n    super.forEach(function(ref) {\n      const value = ref.deref()\n\n      if (!value) {\n        return\n      }\n\n      forEachFn.call(thisArg, value, value, set)\n    })\n  }\n\n  /**\n   * Returns an iterator for the values in the RefSet. Each value is\n   * dereferenced from its WeakRef before being returned. This method allows\n   * iterating over he set's values, similar to how one would iterate over\n   * values in a standard Set or Array, but with the understanding that the\n   * values are weakly referenced and may no longer exist (in which case\n   * they are skipped).\n   *\n   * @returns {Iterator} An iterator for the values.\n   */\n  values() {\n    const values = []\n\n    for (const value of this) {\n      const dereferenced = value.deref()\n\n      if (dereferenced) {\n        values.push(dereferenced)\n      }\n    }\n\n    return values\n  }\n\n  /**\n   * Returns an iterator for the keys of the RefSet. In RefSet, keys and\n   * values are identical, so this method behaves the same as `values()`. It\n   * provides compatibility with the standard Set interface and allows use in\n   * contexts where keys are expected, despite RefSet not differentiating\n   * between keys and values.\n   *\n   * @returns {Iterator} An iterator for the keys.\n   */\n  keys() {\n    return this.values()\n  }\n\n  /**\n   * Determines whether an element with the specified value exists in the\n   * `RefSet`. For non-objectified sets, this method checks if the dereferenced\n   * values of the set include the specified value.\n   *\n   * For objectified sets, it uses the `contains` method which accounts for\n   * the objectification. This method differs from standard Set `has` in that\n   * it works with weak references and considers objectification settings.\n   *\n   * @param {*} value - The value to check for presence in the RefSet.\n   * @returns {boolean} - True if an element with the specified value exists\n   * in the RefSet, false otherwise.\n   */\n  has(value) {\n    if (this.#objectifyValues) {\n      return this.contains(value)\n    }\n\n    for (const item of this.values()) {\n      if (item === value) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Checks if the RefSet contains a value that is equal to the specified\n   * value. This method is used primarily in objectified RefSets to determine\n   * the presence of a value, taking into account objectification. It differs\n   * from the `has` method in that it's tailored for sets that have\n   * transformed their primitive values into objects, whereas `has` is more\n   * general-purpose.\n   *\n   * @param {*} value - The value to search for in the RefSet.\n   * @returns {boolean} - True if the RefSet contains the value, false otherwise.\n   */\n  contains(value) {\n    return !!(Array.from(this.values())\n      .filter(dereferencedValue => {\n       return value == dereferencedValue\n      })\n      .length\n    )\n  }\n\n  /**\n   * Creates a new array with all elements that pass the test implemented by\n   * the provided function. This method iterates over each element,\n   * dereferences it, and applies the filter function. Unlike Array `filter`,\n   * the callback receives the dereferenced value and not an index or array,\n   * reflecting the non-indexed nature of RefSet. Useful for selectively\n   * creating arrays from the set based on certain conditions, especially when\n   * dealing with weak references.\n   *\n   * @param {Function} filterFn - Function to test each element of the RefSet.\n   * The function receives the dereferenced value.\n   * @param {*} thisArg - Value to use as `this` when executing `filterFn`.\n   * @returns {Array} - A new array with the elements that pass the test.\n   */\n  filter(filterFn, thisArg) {\n    const results = []\n\n    for (const value of this) {\n      const dereferenced = value?.deref()\n\n      if (dereferenced) {\n        const include = filterFn.call(thisArg, dereferenced, NaN, this)\n\n        if (include) {\n          results.push(dereferenced)\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Returns the value of the first element in the RefSet that satisfies the\n   * provided testing function. Similar to Array `find`, this method iterates\n   * over the RefSet, dereferencing each value and applying the testing\n   * function. The non-indexed nature of RefSet is considered, as the\n   * callback does not receive an index. This method is useful for finding a\n   * specific element based on a condition.\n   *\n   * @param {*} thisArg - Value to use as this when executing findFn.\n   * @returns {*} - The value of the first element in the RefSet that satisfies\n   * the testing function, or undefined if none found.\n   * @returns {any} the dereferenced value if found, or undefined otherwise\n   */\n  find(findFn, thisArg) {\n    for (const value of this) {\n      const dereferenced = value?.deref()\n\n      if (dereferenced) {\n        const found = findFn.call(thisArg, dereferenced, NaN, this)\n\n        if (found) {\n          return dereferenced\n        }\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * Creates a new array or `RefSet` with the results of calling a provided\n   * function on every element in the calling `RefSet`. This method dereferences\n   * each value, applies the `mapFn`, and collects the results. If `toRefSet` is\n   * `true`, a new `RefSet` is returned; otherwise, an array. This method\n   * differs from `Array.map` in handling weak references and the potential to\n   * return a new `RefSet` instead of an array.\n   *\n   * @param {Function} mapFn - Function that produces an element of the new\n   * array or `RefSet`, taking three arguments.\n   * @param {*} thisArg - Value to use as this when executing mapFn.\n   * @param {boolean} toRefSet - Determines if the output should be a new\n   * `RefSet` (`true`) or an array (`false`).\n   * @param {boolean} mirrorObjectification - If `true` and `toRefSet` is\n   * `true`, the new `RefSet` mirrors the objectification setting of the\n   * original.\n   * @returns {Array|RefSet} - A new array or `RefSet` with each element being\n   * the result of the `mapFn`.\n   */\n  map(mapFn, thisArg, toRefSet, mirrorObjectification) {\n    const mapped = []\n\n    let validRefSetOutput = true\n    let validRefSetOutputIfObjectified = true\n\n    for (const value of this) {\n      const dereferenced = value?.deref()\n\n      if (dereferenced) {\n        const mappedItem = mapFn.call(thisArg, dereferenced, NaN, this)\n\n        if (validRefSetOutput || validRefSetOutputIfObjectified) {\n          const weakReferenceable = this.#validWeakRefTarget(mappedItem)\n\n          if (!weakReferenceable) {\n            validRefSetOutput = false\n\n            if (validRefSetOutputIfObjectified) {\n              validRefSetOutputIfObjectified =\n                this.#validWeakRefTarget(Object(mappedItem))\n            }\n          }\n        }\n\n        mapped.push(mappedItem)\n      }\n    }\n\n    if (toRefSet) {\n      if (validRefSetOutput) {\n        return new RefSet(mapped).objectifying(\n          mirrorObjectification ? this.objectifyValues : false\n        )\n      }\n\n      if (validRefSetOutputIfObjectified) {\n        return new RefSet(mapped.map(value => {\n          return this.#validWeakRefTarget(value) ? value : Object(value)\n        })).objectifying()\n      }\n    }\n\n    return mapped\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Private method to check if a given value is a valid target for a WeakRef.\n   *\n   * @param {*} value - The value to check for validity as a WeakRef target.\n   * @returns {boolean} - True if the value is a valid WeakRef target,\n   * false otherwise.\n   * @private\n   */\n  #validWeakRefTarget(value) {\n    return !(\n      (typeof value === 'symbol' && Symbol.keyFor(value) === undefined) ||\n      (typeof value !== 'object' && typeof value !== 'symbol') ||\n      (value === null || value === undefined)\n    )\n  }\n}\n\nexport const RefSetExtensions = new Extension(RefSet)", "import { Patch } from '@nejs/extension'\n\nexport const WeakRefExtensions = new Patch(WeakRef, {\n  /**\n   * A static method to check if a given value is a valid target for a WeakRef.\n   *\n   * @param {*} value - The value to check for validity as a WeakRef target.\n   * @returns {boolean} - True if the value is a valid WeakRef target,\n   * false otherwise.\n   */\n  isValidReference(value) {\n    return !(\n      (typeof value === 'symbol' && Symbol.keyFor(value) === undefined) ||\n      (typeof value !== 'object' && typeof value !== 'symbol') ||\n      (value === null || value === undefined)\n    )\n  },\n})", "import { Extension } from '@nejs/extension'\n\n/**\n * The Iterable class is designed to provide a convenient way to create synchronous\n * iterable objects. It can be initialized with either an array or individual elements.\n * This class implements the iterable protocol, allowing instances to be used with\n * `for...of` loops and other standard JavaScript iteration mechanisms.\n */\nexport class Iterable {\n  /**\n   * Private field to store the elements of the iterable.\n   * @private\n   */\n  #elements = [];\n\n  /**\n   * Constructs an instance of Iterable. It can be initialized with either an\n   * iterable object (such as an array, Set, Map, string, or any object\n   * implementing the iterable protocol) or individual elements. If the first\n   * argument is an iterable, the class instance is initialized with the\n   * elements from the iterable, followed by any additional arguments. If the\n   * first argument is not an iterable, all arguments are treated as individual\n   * elements.\n   *\n   * @param {Iterable|*} elementsOrFirstElement - An iterable object or the\n   * first element.\n   * @param {...*} moreElements - Additional elements if the first argument is\n   * not an iterable.\n   */\n  constructor(elementsOrFirstElement, ...moreElements) {\n    if (\n      elementsOrFirstElement != null &&\n      typeof elementsOrFirstElement[Symbol.iterator] === 'function'\n    ) {\n      this.#elements = [...elementsOrFirstElement, ...moreElements];\n    } else {\n      this.#elements = [elementsOrFirstElement, ...moreElements];\n    }\n  }\n\n  /**\n   * Implements the iterable protocol. When an instance of Iterable is used\n   * in a `for...of` loop or spread syntax, this generator function is invoked\n   * to yield the elements one by one in a synchronous manner.\n   *\n   * @returns {Generator} A generator that yields each element of the iterable.\n   */\n  *[Symbol.iterator]() {\n    for (const element of this.#elements) {\n      yield element;\n    }\n  }\n\n  /**\n   * Provides access to the elements as a standard array. Useful for scenarios\n   * where array methods and behaviors are needed.\n   *\n   * @returns {Array} An array containing all the elements of the iterable.\n   */\n  get asArray() {\n    return this.#elements;\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Checks if a given value is an iterable. This method determines if the\n   * provided value has a `Symbol.iterator` property that is a generator\n   * function. It's a precise way to identify if the value conforms to the\n   * iterable protocol using a generator function.\n   *\n   * Note: This method specifically checks for generator functions. Some\n   * iterables might use regular functions that return an iterator, which\n   * this method won't identify.\n   *\n   * @param {*} value - The value to be checked for iterability.\n   * @returns {boolean} - Returns true if the value is an iterable implemented\n   * using a generator function, false otherwise.\n   */\n  static isIterable(value) {\n    const type = Object.prototype.toString.call(value?.[Symbol.iterator]);\n    return type === '[object GeneratorFunction]';\n  }\n}\n\n/**\n * Being able to create a compliant `Iterator` around any type of iterable\n * object. This can be wrapped around any type of object that has a\n * `[Symbol.iterator]` property assigned to a generator function.\n */\nexport class Iterator {\n  /**\n   * A private function that when provided has the following signature:\n   * `function mapEach(entry) -> entry`. This allows any changes to be made\n   * to each element, conditionally and programmatically, as needed before\n   * they are returned to the called code.\n   */\n  #mapEach = undefined\n\n  /**\n   * Creates a new `Iterator` object instance.\n   *\n   * @param {object} iterable any object that has a `[Symbol.iterator]`\n   * property assigned to a generator function.\n   * @param {function} mapEach when provided `mapEach` is a callback that\n   * takes an entry as input and receives one as output.\n   */\n  constructor(iterable, mapEach) {\n    if (!iterable || !Reflect.has(iterable, Symbol.iterator)) {\n      throw new TypeError(\n        'Value used to instantiate Iterator is not iterable'\n      );\n    }\n\n    this.#iterable = iterable;\n    this.#iterator = iterable[Symbol.iterator]();\n    this.#mapEach = typeof mapEach === 'function' ? mapEach : undefined\n  }\n\n  /**\n   * Returns a new `Array` derived from the iterable this object\n   * wraps.\n   *\n   * @returns {array} a new `Array` generated from the wrapped\n   * iterable. The method is generated from `Array.from()`\n   */\n  get asArray() {\n    return Array.from(this.#iterable)\n  }\n\n  /**\n   * Returns the actual iterable object passed to the constructor that\n   * created this instance.\n   *\n   * @returns {object} the object containing the `[Symbol.iterator]`\n   */\n  get iterable() {\n    return this.#iterable\n  }\n\n  /**\n   * The function retrieves the next value in the iterator. If the\n   * the iterator has run its course, `reset()` can be invoked to\n   * reset the pointer to the beginning of the iteration.\n   *\n   * @returns {any} the next value\n   */\n  next() {\n    const input = this.#iterator.next();\n    let output = input\n\n    if (output.done) {\n      return { value: undefined, done: true };\n    }\n    else {\n      if (this.#mapEach && typeof this.#mapEach === 'function') {\n        output.value = this.#mapEach(input.value)\n      }\n\n      return { value: output.value, done: false };\n    }\n  }\n\n  /**\n   * Resets the iterator to the beginning allowing it to be\n   * iterated over again.\n   */\n  reset() {\n    this.#iterator = this.#iterable[Symbol.iterator]();\n  }\n\n  /**\n   * The existence of this symbol on the object instances, indicates that\n   * it can be used in `for(.. of ..)` loops and its values can be\n   * extracted from calls to `Array.from()`\n   *\n   * @returns {Iterator} this is returned since this object is already\n   * conforming to the expected JavaScript Iterator interface\n   */\n  [Symbol.iterator]() {\n    return this;\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * The object from which its iterator functionality is derived.\n   *\n   * @type {object}\n   * @private\n   */\n  #iterable = null;\n\n  /**\n   * The results of a call to the iterable's `[Symbol.iterator]`\n   * generator function.\n   *\n   * @type {object}\n   * @private\n   */\n  #iterator = null;\n}\n\nexport const IterableExtensions = new Extension(Iterable)\nexport const IteratorExtensions = new Extension(Iterator)", "import { Extension } from '@nejs/extension'\nimport { ObjectExtensions } from '../objectextensions.js'\nimport { SymbolExtensions } from '../symbolextensions.js'\nimport { WeakRefExtensions } from '../weakrefextensions.js'\nimport { Iterable, Iterator } from './iterable.js'\n\nconst { isObject, isNullDefined, isValidKey } = ObjectExtensions.patches\nconst { isRegistered } = SymbolExtensions.patches\nconst { isValidReference } = WeakRefExtensions.patches\n\n/**\n * RefMap class extends the standard Map object to manage a collection of\n * WeakRef values mapped to strong keys. It provides additional functionality\n * such as objectification of values and various utility methods.\n *\n * Unlike standard Maps or Objects, RefMap stores weak references to objects,\n * allowing them to be garbage-collected if there are no other references to\n * them. This behavior is different from Maps and standard Objects, which\n * maintain strong references to their elements.\n *\n * @extends Map\n */\nexport class RefMap extends Map {\n  /**\n   * Private field to track whether the RefMap should objectify primitive\n   * values.\n   *\n   * @private\n   */\n  #objectifyValues = false\n\n  constructor(...args) {\n    super(...args)\n  }\n\n  /**\n   * Method to control whether the RefMap should objectify its values. When\n   * objectifying, primitive values (number, string, boolean, bigint) are\n   * converted to their respective object types, which allows them to be used as\n   * WeakRef targets.\n   *\n   * @param {boolean} setObjectification - Flag to enable or disable\n   * objectification.\n   * @returns {RefMap} - The current RefMap instance to allow method chaining.\n   */\n  objectifying(setObjectification = true) {\n    this.objectifyValues = setObjectification\n    return this\n  }\n\n  /**\n   * The function converts a JavaScript Map object into a regular JavaScript\n   * object, handling invalid keys by converting them to strings.\n   *\n   * @returns {object} an object; keys that are not either a `String` or a\n   * `Symbol` will be converted to a string.\n   */\n  asObject() {\n    const object = {}\n\n    for (const [key, value] of this) {\n      const useKey = isValidKey(key) ? key : String(key)\n      const useValue = value?.valueOf() || value\n\n      object[useKey] = useValue\n    }\n\n    return object\n  }\n\n  /**\n   * Returns the state indicating whether or not `RefMap` will attempt to\n   * convert non-valid primitives into targets that are valid input for\n   * new `WeakRef` object instances. If this value is `false` then no\n   * *objectification* will occur.\n   *\n   * @returns {boolean} The current state of objectifyValues.\n   */\n  get objectifyValues() {\n    return this.#objectifyValues\n  }\n\n\n  /**\n   * The `get` function retrieves a value from a map and returns it, or returns a\n   * default value if the value is null or undefined. The actual retrieved value\n   * is a dereferenced `WeakRef`. If the result is `undefined` and this is not the\n   * expected response, it is likely the value has been garbage collected.\n   *\n   * @param {any} key - The key parameter is the key of the value you want to\n   * retrieve from the data structure.\n   * @param {any} defaultValue - The `defaultValue` parameter is the value that\n   * will be returned if the key does not exist in the map or if the value\n   * associated with the key has been garbage collected (i.e., it no longer\n   * exists).\n   * @returns The method is returning the value associated with the given key.\n   * If the value is not found or if it has been garbage collected (deref()\n   * returns null), then the defaultValue is returned.\n   */\n  get(key, defaultValue) {\n    const value = super.get(key)\n\n    if (!value || !value?.deref()) {\n      return defaultValue\n    }\n\n    return value?.deref()\n  }\n\n  /**\n   * Setting this value to true, will cause all set values to the Map to\n   * be analyzed for validity as a candidate to be wrapped in a `WeakRef`\n   * object. If true, and if possible, the object will be turned into an\n   * `Object` variant first.\n   *\n   * @param {boolean} value - The new state to set for objectifyValues.\n   */\n  set objectifyValues(value) {\n    this.#objectifyValues = !!value\n  }\n\n  /**\n   * Overrides the set method of `Map`. Adds a value to the `RefMap`,\n   * converting it to a `WeakRef`. Throws an error if the value is not a\n   * valid `WeakRef` target (e.g., `null`, `undefined`, or a registered\n   * `symbol`). If {@link objectifyValues} is enabled, an attempt to convert\n   * primitives to their object variants will be made. These are `numbers`,\n   * `strings`, `boolean` values and `bigint`s.\n   *\n   * @param {*} key - The `key` to be set on the `RefMap`\n   * @param {*} value - The value to be associated with the `key`\n   * @throws {TypeError} If the value is not a valid WeakRef target.\n   */\n  set(key, value) {\n    let useValue = value\n\n    // Objectify the value if needed\n    if (this.#objectifyValues && (\n      typeof useValue === 'number' ||\n      typeof useValue === 'string' ||\n      typeof useValue === 'boolean' ||\n      typeof useValue === 'bigint'\n    )) {\n      useValue = Object(useValue);\n    }\n\n    // Check if the value is an object, and if it's a symbol, ensure it's not registered\n    if (typeof useValue === 'symbol' && Symbol.keyFor(useValue) !== undefined) {\n      throw new TypeError('RefMap cannot accept registered symbols as values');\n    }\n\n    if (typeof useValue !== 'object' && typeof useValue !== 'symbol') {\n      throw new TypeError(\n        'RefMap values must be objects, non-registered symbols, or objectified primitives'\n      );\n    }\n\n    // If the value is null or undefined, throw an error\n    if (useValue === null || useValue === undefined) {\n      throw new TypeError('RefMap values cannot be null or undefined');\n    }\n\n    const ref = new WeakRef(useValue)\n\n    super.set(key, ref)\n  }\n\n  /**\n   * Sets multiple values at a single time. The format is an array of array\n   * or rather an array of {@link Object.entries} (for example,\n   * `[[key1,value1], [key2,value2]]`). For each entry pair, if the length\n   * is not 2, either missing a key or value, it will be skipped.\n   *\n   * @param {Iterable} values - An iterable of values to add to the RefMap.\n   * @throws {TypeError} If the supplied values are falsey or non-iterable.\n   * @returns {RepMap} returns `this` to allow for chaining\n   */\n  setAll(entries) {\n    if (!Iterable.isIterable(entries)) {\n      throw new TypeError(\n        'The supplied list of entries must be an array of arrays in the ' +\n        'format [[key1, value1], [key2, value2], ...].'\n      )\n    }\n\n    const forEach = entry => {\n      const [key, value] = entry\n\n      if (!key || !isObject(value) || !isRegistered(value)) {\n        return\n      }\n\n      this.set(key, value)\n    }\n\n    for (const entry of entries) {\n      forEach(entry)\n    }\n\n    return this\n  }\n\n  /**\n   * Removes all elements from the RefMap that have been garbage collected\n   * (i.e., their WeakRef no longer points to an object).\n   *\n   * @returns {RefMap} - The current RefMap instance to allow method chaining.\n   */\n  clean() {\n    for (const [key, dereferenced] of this) {\n      if (!dereferenced) {\n        this.delete(key)\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Executes a provided function once for each value in the RefMap. The callback\n   * function receives the dereferenced value, the value again (as RefMap doesn't\n   * use keys), and the RefMap itself. This method provides a way to iterate over\n   * and apply operations to the values stored in the RefMap, taking into account\n   * that they are weak references and may have been garbage-collected.\n   *\n   * @param {Function} forEachFn - Function to execute for each element. It\n   * takes three arguments: element, element (again, as RefMap has no key), and\n   * the RefMap itself.\n   * @param {*} thisArg - Value to use as `this` when executing `forEachFn`.\n   */\n  entries() {\n    const entriesIterator = super.entries()\n    const refIterator = new Iterator(entriesIterator, (entry) => {\n      if (entry) {\n        const [key, ref] = entry\n        const value = ref?.deref()\n\n        return [key, value]\n      }\n\n      return entry\n    })\n\n    return refIterator\n  }\n\n  /**\n   * Iterate over the items in the map and pass them to the supplied\n   * function ala `Map.prototype.forEach`. Note however, there are no\n   * indexes on Maps and as such, the index parameter of the callback\n   * will always be the value's key. Subsequently the `array` or third\n   * parameter will receive the map instance rather than an array.\n   *\n   * @param {function} forEachFn the function to use for each element in\n   * the set.\n   * @param {object} thisArg the `this` argument to be applied to each\n   * invocation of the `forEachFn` callback. Note, this value is unable\n   * to be applied if the `forEachFn` is a big arrow function\n   */\n  forEach(forEachFn, thisArg) {\n    for (const [key, ref] of super.entries()) {\n      const value = ref?.deref()\n\n      if (!value) {\n        continue\n      }\n\n      forEachFn.call(thisArg, value, key, this)\n    }\n  }\n\n  /**\n   * Returns an iterator for the values in the RefMap. Each value is\n   * dereferenced from its WeakRef before being returned. This method allows\n   * iterating over he set's values, similar to how one would iterate over\n   * values in a standard Map or Array, but with the understanding that the\n   * values are weakly referenced and may no longer exist (in which case\n   * they are skipped).\n   *\n   * @returns {Iterator} An iterator for the values.\n   */\n  values() {\n    return new Iterator(super.values(), function perItem(value) {\n      const dereferenced = value?.deref()\n      return dereferenced || value\n    })\n  }\n\n  /**\n   * Determines whether an element with the specified value exists in the\n   * `RefMap`. For non-objectified sets, this method checks if the dereferenced\n   * values of the map include the specified value.\n   *\n   * For objectified sets, strict is set to false which uses loose\n   * equality to allow for things like `Object(5)` to equal `5`. This is important\n   * because otherwise primitives could not be weakly referenced. In the grand\n   * scheme of things, this is only useful if the objectified value is the\n   * one being referenced.\n   *\n   * @param {*} value - The value to check for presence in the RefMap.\n   * @param {boolean} strict - if `true`, the default, then the supplied value\n   * is hard compared to the dereferenced value (`===`). If `false`, then a\n   * loose comparison is used (`==`)\n   * @returns {boolean} - True if an element with the specified value exists\n   * in the RefMap, false otherwise.\n   */\n  hasValue(value, strict = true) {\n    if (isNullDefined(value)) {\n      return false\n    }\n\n    if (this.#objectifyValues) {\n      strict = false\n    }\n\n    for (const [_, dereferenced] of this) {\n      if (\n        (strict && value === dereferenced) ||\n        (!strict && value == dereferenced)\n      ) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * The `filter` function filters the entries of a `RefMap` object based on\n   * a given filter function. The dereferenced entries of the values of the map\n   * will be passed to the function rather than a `WeakRef` itself.\n   *\n   * A new resulting entry set will be generated and a new `RefMap` will be made\n   * from these entries and returned. Note that this function never returns\n   * `null`\n   *\n   * @param {function} filterFn - The `filterFn` parameter is a function that\n   * will be used to filter the entries in the `RefMap`. It will be called with\n   * three arguments: the value of the current entry, the key of the current\n   * entry, and the `RefMap` itself. The function should return `true`\n   * @param {object} thisArg - The `thisArg` parameter is an optional argument\n   * that specifies the value to be used as `this` when executing the\n   * `filterFn` function. It allows you to explicitly set the context in which\n   * the `filterFn` function is called. If `thisArg` is not provided, `this\n   * @returns {array} The `filter` method is returning an array of filtered map\n   * entries\n   */\n  filter(filterFn, thisArg) {\n    const resultingEntries = []\n\n    for (const [key, dereferenced] of this) {\n      if (filterFn.call(thisArg, dereferenced, key, this)) {\n        resultingEntries.push([key, dereferenced])\n      }\n    }\n\n    return resultingEntries\n  }\n\n  /**\n   * The `find` function iterates over a map and calls a given function on\n   * each value, returning the first value for which the function returns\n   * a truthy value.\n   *\n   * The function signature of `findFn` is\n   * ```\n   * function findFn(value, key, map)\n   * ```\n   * 'value' is passed to findFn up to two times; first with the `WeakRef`\n   * value, second with the result of {@link WeakRef.deref}. If `findFn`\n   * returns true for either of these the dereferenced value will be\n   * returned from the call to {@link RefMap.find}.\n   * `key` represents the key object that the value is mapped to.\n   * `map` is simply a reference to `this` map.\n   *\n   * @param findFn - `findFn` is a function that will be called for each\n   * element in the map. It takes three arguments: `ref`, `key`, and `map`;\n   * where `ref` is the value of the current element in the map, `key` is\n   * the key of the current element, and `map` is a reference to the instance\n   * being searched.\n   * @param thisArg - The `thisArg` parameter is the value to be used as\n   * the `this` value when executing the `findFn` function. It allows you\n   * to specify the context in which the `findFn` function should be called.\n   * @returns the first dereferenced value that satisfies the condition\n   * specified by the `findFn` function. If no value satisfies the condition,\n   * it returns `null`.\n   */\n  find(findFn, thisArg) {\n    for (const [key, dereferenced] of this) {\n      const ref = super.get(key)\n      let result = findFn.call(thisArg, ref, key, map)\n\n      if (!result) {\n        result = findFn.call(thisArg, dereferenced, key, map)\n      }\n\n      if (result) {\n        return dereferenced\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Creates a new array or `RefMap` with the results of calling a provided\n   * function on every element in the calling `RefMap`. This method dereferences\n   * each value, applies the `mapFn`, and collects the results. If `toRefMap` is\n   * `true`, a new `RefMap` is returned; otherwise, an array. This method\n   * differs from `Array.map` in handling weak references and the potential to\n   * return a new `RefMap` instead of an array.\n   *\n   * @param {Function} mapFn - Function that produces an element of the new\n   * array or `RefMap`, taking three arguments.\n   * @param {*} thisArg - Value to use as this when executing mapFn.\n   * @param {boolean} toRefMap - Determines if the output should be a new\n   * `RefMap` (`true`) or an array (`false`).\n   * @param {boolean} mirrorObjectification - If `true` and `toRefMap` is\n   * `true`, the new `RefMap` mirrors the objectification setting of the\n   * original.\n   * @returns {Array|RefMap} - A new array or `RefMap` with each element being\n   * the result of the `mapFn`.\n   */\n  map(mapFn, thisArg, toRefMap, mirrorObjectification) {\n    if (typeof mapFn !== 'function') {\n      throw new TypeError('mapFn must be a function! Received', mapFn)\n    }\n\n    const entries = []\n    const errors = []\n\n    let needsObjectification = mirrorObjectification && this.objectifyValues\n    let detectNeed = mirrorObjectification === undefined\n    let objectify = needsObjectification\n\n    for (const [key, dereferenced] of this) {\n      const [, VALUE] = [0,1]\n      const transformed = mapFn.call(thisArg, [key, dereferenced], key, this)\n\n      if (!isValidReference(transformed[VALUE])) {\n        if (isValidReference(Object(transformed[VALUE]))) {\n          needsObjectification = true\n          if (detectNeed && !objectify) {\n            objectify = true\n            transformed[VALUE] = Object(transformed[VALUE])\n          }\n        }\n      }\n\n      entries.push(transformed)\n    }\n\n    if (toRefMap) {\n      return new RefMap(entries).objectifying(objectify)\n    }\n\n    return entries\n  }\n\n  /**\n   * The function returns an iterator that iterates over the entries of an object,\n   * dereferencing any weak references.\n   *\n   * @returns {Iterator} A new iterator object is being returned.\n   */\n  *[Symbol.iterator]() {\n    for (const [key, ref] of this.entries()) {\n      yield [key, ref]\n    }\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n\nexport const RefMapExtensions = new Extension(RefMap)", "import { Extension } from '@nejs/extension'\n\n/**\n * Deferreds, which were first introduced by jQuery for browsers in the early\n * 2000s, are a way to manage asynchronous operations. They have been widely\n * used and replicated by engineers since then. Although the Promise class in\n * modern JavaScript provides a static method called `withResolvers` that\n * returns an object with similar properties to a Deferred, it is not directly\n * supported by Node.js.\n *\n * ```\n * const withResolvers = Promise.withResolvers()\n * Reflect.has(withResolvers, 'promise') // true\n * Reflect.has(withResolvers, 'resolve') // true\n * Reflect.has(withResolvers, 'reject')  // true\n * ```\n *\n * This Deferred class extends the Promise class, allowing it to capture the\n * value or reason for easy access after resolution, akin to\n * {@link Promise.withResolvers}. As it extends {@link Promise}, it is\n * 'thenable' and works with `await` as if it were a native Promise. This\n * allows seamless integration with code expecting Promise-like objects.\n */\nexport class Deferred extends Promise {\n  /**\n   * The promise backing this deferred object. Created when the constructor\n   * runs, this promise is what all `Promise.prototype` functions are routed\n   * to.\n   *\n   * @type {Promise}\n   */\n  #promise = null\n\n  /**\n   * The reject() resolver that will be assigned when a new instance is\n   * created. Invoking this function with or without a `reason` will cause\n   * the deferred's promise to be settled.\n   *\n   * @type {function}\n   */\n  #reject = null\n\n  /**\n   * The resolve() resolver that will be assigned when a new instance is\n   * created. Invoking this function with or without a `value` will cause\n   * the deferred's promise to be settled.\n   *\n   * @type {function}\n   */\n  #resolve = null\n\n  /**\n   * When the Deferred is settled with {@link Deferred.resolve}, the `value`\n   * passed to that function will be set here as well.\n   *\n   * @type {*}\n   */\n  value = null\n\n  /**\n   * When the Deferred is settled with {@link Deferred.reject}, the `reason`\n   * passed to that rejection will also be stored here.\n   *\n   * @type {*}\n   */\n  reason = null\n\n  /**\n   * When either {@link Deferred.resolve} or {@link Deferred.reject} are called,\n   * this property is set to `true`. Its current status at any time can be\n   * queried using the {@link Deferred.settled} getter.\n   *\n   * @type {boolean}\n   */\n  #settled = false\n\n  /**\n   * The constructor for Deferred instances. By default, a new Deferred will\n   * have three important properties: `promise`, `resolve`, and `reject`.\n   *\n   * The constructor takes an object called `options`. It can have the\n   * following properties:\n   *\n   * ```\n   * interface BaseDeferredOptions {\n   *   // Deferreds store the value or reason. To turn this off, pass true\n   *   // to this option.\n   *   doNotTrackAnswers?: boolean;\n   * }\n   *\n   * interface ResolveDeferredOptions {\n   *   // Passing in an option object with a resolve value will auto resolve\n   *   // the Deferred with your value. An error will be raised if both\n   *   // resolve and reject are supplied at the same time.\n   *   resolve?: (value: any) => void;\n   * }\n   *\n   * interface RejectDeferredOptions {\n   *   // Passing in an option object with a reject reason will auto reject\n   *   // the Deferred with your reason. An error will be raised if both\n   *   // resolve and reject are supplied at the same time.\n   *   reject?: (reason: any) => void;\n   * }\n   *\n   * type DeferredOptions = BaseDeferredOptions &\n   *   (ResolveDeferredOptions | RejectDeferredOptions)\n   * ```\n   *\n   * @param {object} options see above for examples on supported options, but\n   * when supplied, the constructor can take instructions on how to auto\n   * resolve or reject the deferred created here.\n   */\n  constructor(options) {\n    // Check if options is an object, if not, assign an empty object to config\n    const config = (options && typeof(options) === 'object'\n      ? options\n      : {}\n    )\n\n    // Throw an error if both resolve and reject options are provided\n    if (config?.resolve && config?.reject) {\n      throw new TypeError(\n        'resolve and reject options cannot be simultaneously provided'\n      )\n    }\n\n    // Create an empty object to store the resolve and reject functions\n    let _resolve, _reject;\n\n    // Create a new promise and assign its resolve and reject functions to resolvers\n    super((resolve, reject) =>{\n      _resolve = resolve\n      _reject = reject\n\n      if (config?.executor && typeof(config?.executor) === 'function') {\n        config?.executor(resolve, reject)\n      }\n    })\n\n    // Define the resolve function for the Deferred instance\n    this.#resolve = (value) => {\n      // If doNotTrackAnswers is not set to true, store the value\n      if (config?.doNotTrackAnswers !== true) {\n        this.value = value\n      }\n      // Mark the Deferred instance as settled\n      this.#settled = true\n      // Resolve the promise with the provided value\n      return _resolve(value)\n    }\n\n    // Define the reject function for the Deferred instance\n    this.#reject = async (reason) => {\n      // If doNotTrackAnswers is not set to true, store the reason\n      if (config?.doNotTrackAnswers !== true) {\n        this.reason = reason\n      }\n      // Mark the Deferred instance as settled\n      this.#settled = true\n      // Reject the promise with the provided reason\n      return _reject(reason)\n    }\n\n    this.#promise = this\n\n    // If a resolve option is provided, resolve the Deferred instance with it\n    if (config?.resolve) {\n      this.#resolve(config?.resolve)\n    }\n    // If a reject option is provided, reject the Deferred instance with it\n    else if (config?.reject) {\n      this.#reject(config?.reject)\n    }\n  }\n\n  /**\n   * Returns a boolean value that indicates whether or not this Deferred\n   * has been settled (either resolve or reject have been invoked).\n   *\n   * @returns {boolean} `true` if either {@link Deferred.resolve} or\n   * {@link Deferred.reject} have been invoked; `false` otherwise\n   */\n  get settled() {\n    return this.#settled\n  }\n\n  /**\n   * Accessor for the promise managed by this Deferred instance.\n   *\n   * This getter provides access to the internal promise which is controlled\n   * by the Deferred's resolve and reject methods. It allows external code to\n   * attach callbacks for the resolution or rejection of the Deferred without\n   * the ability to directly resolve or reject it.\n   *\n   * @returns {Promise} The promise controlled by this Deferred instance.\n   */\n  get promise() {\n    return this.#promise\n  }\n\n  /**\n   * Resolves the Deferred with the given value. If the value is a thenable\n   * (i.e., has a \"then\" method), the Deferred will \"follow\" that thenable,\n   * adopting its eventual state; otherwise, the Deferred will be fulfilled\n   * with the value. This function behaves the same as Promise.resolve.\n   *\n   * @param {*} value - The value to resolve the Deferred with.\n   * @returns {Promise} A Promise that is resolved with the given value.\n   */\n  resolve(value) {\n    return this.#resolve(value)\n  }\n\n  /**\n   * Rejects the Deferred with the given reason. This function behaves the\n   * same as Promise.reject. The Deferred will be rejected with the provided\n   * reason.\n   *\n   * @param {*} reason - The reason to reject the Deferred with.\n   * @returns {Promise} A Promise that is rejected with the given reason.\n   */\n  reject(reason) {\n    return this.#reject(reason)\n  }\n\n  /**\n   * A getter for the species symbol which returns a custom DeferredPromise\n   * class. This class extends from Deferred and is used to ensure that the\n   * constructor signature matches that of a Promise. The executor function\n   * passed to the constructor of this class is used to initialize the Deferred\n   * object with resolve and reject functions, similar to how a Promise would\n   * be initialized.\n   *\n   * @returns {DeferredPromise} A DeferredPromise class that extends Deferred.\n   */\n  static get [Symbol.species]() {\n    return class DeferredPromise extends Deferred {\n      /**\n       * The constructor for the DeferredPromise class.\n       * It takes an executor function which is used to initialize the Deferred.\n       *\n       * @param {Function} executor - A function that is passed with the resolve\n       * and reject functions. The executor is expected to initialize the\n       * Deferred by calling resolve or reject at some point.\n       */\n      constructor(executor) {\n        super({executor})\n      }\n    }\n  }\n}\n\nexport const DeferredExtension = new Extension(Deferred)", "import { Extension } from '@nejs/extension'\n\n/**\n * The AsyncIterable class extends the concept of Iterable to asynchronous\n * operations. It allows creating iterable objects where each element can be\n * an asynchronous entity, like a Promise. This class is particularly useful\n * when dealing with asynchronous data sources, such as API responses, file\n * reading in chunks, or any other data that is not immediately available but\n * arrives over time.\n */\nexport class AsyncIterable {\n  /**\n   * Private field to store the elements of the async iterable.\n   * @private\n   */\n  #elements = [];\n\n  /**\n   * Constructs an instance of AsyncIterable. Similar to Iterable, it can be\n   * initialized with either an iterable object, an async generator function,\n   * or individual elements. The elements can be promises, direct values, or a\n   * mix of both. If the first argument is an iterable or an async generator\n   * function, the instance is initialized with the elements from the iterable\n   * or the generated elements from the async generator function, followed by\n   * any additional arguments. If the first argument is not an iterable or an\n   * async generator function, all arguments are treated as individual elements.\n   *\n   * @param {Iterable|AsyncGeneratorFunction|Promise|*} elementsOrFirstElement - \n   * An iterable object, an async generator function, a Promise, or the first \n   * element.\n   * @param {...Promise|*} moreElements - Additional elements if the first\n   * argument is not an iterable or an async generator function.\n   */\n  constructor(elementsOrFirstElement, ...moreElements) {\n    if (\n      elementsOrFirstElement != null &&\n      (typeof elementsOrFirstElement[Symbol.iterator] === 'function' ||\n       typeof elementsOrFirstElement[Symbol.asyncIterator] === 'function')\n    ) {\n      this.#elements = [...elementsOrFirstElement, ...moreElements];\n    } else if (\n      typeof elementsOrFirstElement === 'function' &&\n      elementsOrFirstElement.constructor.name === 'AsyncGeneratorFunction'\n    ) {\n      this.#elements = elementsOrFirstElement();\n    } else {\n      this.#elements = [elementsOrFirstElement, ...moreElements];\n    }\n  }\n\n  /**\n   * Implements the async iterable protocol. When an instance of AsyncIterable\n   * is used in a `for await...of` loop, this async generator function is\n   * invoked. It yields each element as a Promise, allowing asynchronous\n   * iteration. Elements that are not Promises are automatically wrapped in\n   * a resolved Promise to ensure consistency.\n   *\n   * @returns {AsyncGenerator} An async generator that yields each element as\n   * a Promise.\n   */\n  async *[Symbol.asyncIterator]() {\n    for await (const element of this.#elements) {\n      // No need to wrap as a promise here since `for await...of` can handle\n      // both Promises and non-Promise values.\n      yield element;\n    }\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Checks if a given value is an async iterable. This method determines if\n   * the provided value has a `Symbol.asyncIterator` property that is an async\n   * generator function. It's a precise way to identify if the value conforms\n   * to the async iterable protocol using an async generator function.\n   *\n   * Note: This method specifically checks for async generator functions. Some\n   * async iterables might use regular async functions that return an async\n   * iterator, which this method won't identify.\n   *\n   * @param {*} value - The value to be checked for async iterability.\n   * @returns {boolean} - Returns true if the value is an async iterable\n   * implemented using an async generator function, false otherwise.\n   */\n  static isAsyncIterable(value) {\n    const type = Object.prototype.toString.call(value?.[Symbol.asyncIterator]);\n    return type === '[object AsyncGeneratorFunction]';\n  }\n}\n\n/**\n * Being able to create a compliant `AsyncIterator` around any type of\n * iterable object. This can be wrapped around any type of object that\n * has a `[Symbol.asyncIterator]` property assigned to a generator\n * function.\n */\nexport class AsyncIterator {\n  /**\n   * Creates a new `AsyncIterator` object instance.\n   *\n   * @param {object|AsyncGeneratorFunction} asyncIterable any object that has a\n   * `[Symbol.asyncIterable]` property assigned to a generator function or an\n   * async generator function itself.\n   */\n  constructor(asyncIterable) {\n    if (typeof asyncIterable === 'function' &&\n        asyncIterable.constructor.name === 'AsyncGeneratorFunction') {\n      this.#asyncIterable = asyncIterable();\n    } else if (\n      !asyncIterable || \n      !Reflect.has(asyncIterable, Symbol.asyncIterator)\n    ) {\n      throw new TypeError(\n        'Value used to instantiate AsyncIterator is not an async iterable'\n      );\n    } else {\n      this.#asyncIterable = asyncIterable;\n    }\n    this.#asyncIterator = this.#asyncIterable[Symbol.asyncIterator]();\n  }\n\n  /**\n   * Returns a new `Array` derived from the iterable this object\n   * wraps.\n   *\n   * @returns {array} a new `Array` generated from the wrapped\n   * iterable. The method is generated from using an async for of\n   * loop.\n   */\n  async asArray() {\n    const array = []\n\n    for await (const value of this) {\n      array.push(value)\n    }\n\n    return array\n  }\n\n  /**\n   * Returns the actual iterable object passed to the constructor that\n   * created this instance.\n   *\n   * @returns {object} the object containing the `[Symbol.iterator]`\n   */\n  get asyncIterable() {\n    return this.#asyncIterable\n  }\n\n  /**\n   * The function retrieves the next value in the iterator. If the\n   * the iterator has run its course, `reset()` can be invoked to\n   * reset the pointer to the beginning of the iteration.\n   *\n   * @returns {any} the next value\n   */\n  async next() {\n    const result = await this.#asyncIterator.next();\n    if (result.done) {\n      return { value: undefined, done: true };\n    } else {\n      return { value: result.value, done: false };\n    }\n  }\n\n  /**\n   * Resets the async iterator to the beginning allowing it to be\n   * iterated over again.\n   */\n  async reset() {\n    this.#asyncIterator = this.#asyncIterable[Symbol.asyncIterator]();\n  }\n\n  /**\n   * The existence of this symbol on the object instances, indicates that\n   * it can be used in `for(.. of ..)` loops and its values can be\n   * extracted from calls to `Array.from()`\n   *\n   * @returns {AsyncIterable} this is returned since this object is already\n   * conforming to the expected JavaScript AsyncIterator interface\n   */\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  /**\n   * Ensures that the constructor of this object instance's name\n   * is returned if the string tag for this instance is queried\n   *\n   * @returns {string} the name of the class\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n\n  /**\n   * The object from which its iterator functionality is derived.\n   *\n   * @type {object}\n   * @private\n   */\n  #asyncIterable = null;\n\n  /**\n   * The results of a call to the iterable's `[Symbol.asyncIterator]`\n   * generator function.\n   *\n   * @type {object}\n   * @private\n   */\n  #asyncIterator = null;\n}\n\nexport const AsyncIterableExtensions = new Extension(AsyncIterable)\nexport const AsyncIteratorExtensions = new Extension(AsyncIterator)"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Controls", "Extensions", "GlobalFunctionsAndProps", "InstancePatches", "Patches", "StaticPatches", "all", "src_default", "typeOf", "o", "CannotBeExtendedError", "owner", "key", "typeOf", "o", "MissingOwnerValue", "owner", "key", "PatchToggle", "patch", "preventRevert", "depth", "options", "inspect", "objName", "status", "PatchEntry", "property", "owningObject", "condition", "isNullish", "value", "isKey", "types", "f", "isObject", "anotherObject", "bindAccessors", "descriptor", "depth", "options", "inspect", "type", "writable", "Patch", "_Patch", "owner", "patches", "options", "globalCondition", "key", "condition", "PatchEntry", "error", "acc", "patchEntry", "_", "metrics", "entries", "counts", "patch", "oDesc", "#equalDescriptors", "preventRevert", "PatchToggle", "conflicts", "appliedDescriptor", "left", "right", "depth", "inspect", "exprs", "opts", "type", "name", "keys", "#allPatchesForOwner", "allForOwner", "appliedOnly", "wrapInToggle", "applyOnRequest", "onlyApplied", "accumulator", "usage", "toggle", "dynName", "dynNameContainer", "applyTo", "fromString", "primitives", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "metadata", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "exprs", "val", "name", "extensions", "extensionValue", "ObjectExtensions", "Patch", "value", "strict", "owner", "stringTag", "object", "keys", "bindAccessors", "result", "key", "descriptor", "ObjectPrototypeExtensions", "getStringTag", "ObjectExtensions", "FunctionExtensions", "Patch", "value", "stringTag", "FunctionPrototypeExtensions", "MapPrototypeExtensions", "Patch", "value", "strict", "key", "entryValue", "SetPrototypeExtensions", "Patch", "iterables", "iterable", "element", "value", "everyFn", "thisArg", "found", "findFn", "mapFn", "transformed", "reduceFn", "initialValue", "accumulator", "someFn", "isObject", "ObjectExtensions", "ReflectExtensions", "Patch", "object", "keys", "key", "has", "result", "value", "StringExtensions", "Patch", "value", "SymbolExtensions", "Patch", "value", "allowOnlySymbols", "ArrayPrototypeExtensions", "Patch", "value", "entry", "findFn", "entries", "VALUE", "isObject", "isValidKey", "ObjectExtensions", "hasSome", "ReflectExtensions", "Descriptor", "_Descriptor", "#desc", "#object", "object", "key", "value", "depth", "options", "inspect", "wrap", "forKey", "bindAccessors", "descriptor", "hint", "hasGetter", "hasSetter", "property", "enumerable", "configurable", "getter", "setter", "writable", "knownKeys", "object_orProp", "DATA_KEYS", "validData", "ACCESSOR_KEYS", "validAccessor", "DescriptorExtensions", "Extension", "isClass", "isFunction", "FunctionExtensions", "CustomInspect", "GlobalFunctionsAndProps", "Patch", "object", "classPrototype", "options", "prototype", "toPrimitive", "base", "proto", "klass", "hint", "depth", "opts", "inspect", "stringKey", "numberKey", "targetKey", "property", "isNum", "RefSet", "_RefSet", "#objectifyValues", "setObjectification", "value", "values", "ref", "_", "forEachFn", "thisArg", "set", "dereferenced", "item", "dereferencedValue", "filterFn", "results", "findFn", "mapFn", "toRefSet", "mirrorObjectification", "mapped", "validRefSetOutput", "validRefSetOutputIfObjectified", "mappedItem", "#validWeakRefTarget", "RefSetExtensions", "Extension", "WeakRefExtensions", "Patch", "value", "Iterable", "#elements", "elementsOrFirstElement", "moreElements", "element", "value", "Iterator", "#mapEach", "iterable", "mapEach", "#iterable", "#iterator", "input", "output", "IterableExtensions", "Extension", "IteratorExtensions", "isObject", "isNullDefined", "isValidKey", "ObjectExtensions", "isRegistered", "SymbolExtensions", "isValidReference", "WeakRefExtensions", "RefMap", "_RefMap", "#objectifyValues", "args", "setObjectification", "object", "key", "value", "useKey", "useValue", "defaultValue", "ref", "entries", "Iterable", "forEach", "entry", "dereferenced", "entriesIterator", "Iterator", "forEachFn", "thisArg", "strict", "_", "filterFn", "resultingEntries", "findFn", "result", "mapFn", "toRefMap", "mirrorObjectification", "errors", "needsObjectification", "detectNeed", "objectify", "VALUE", "transformed", "RefMapExtensions", "Extension", "Deferred", "_Deferred", "#promise", "#reject", "#resolve", "#settled", "options", "config", "_resolve", "_reject", "resolve", "reject", "value", "reason", "executor", "DeferredExtension", "Extension", "AsyncIterable", "#elements", "elementsOrFirstElement", "moreElements", "element", "value", "AsyncIterator", "asyncIterable", "#asyncIterable", "#asyncIterator", "array", "result", "AsyncIterableExtensions", "Extension", "AsyncIteratorExtensions", "StaticPatches", "ObjectExtensions", "FunctionExtensions", "ReflectExtensions", "StringExtensions", "SymbolExtensions", "InstancePatches", "ObjectPrototypeExtensions", "FunctionPrototypeExtensions", "ArrayPrototypeExtensions", "MapPrototypeExtensions", "SetPrototypeExtensions", "Patches", "Extensions", "AsyncIterableExtensions", "AsyncIteratorExtensions", "DeferredExtension", "DescriptorExtensions", "IterableExtensions", "IteratorExtensions", "RefMapExtensions", "RefSetExtensions", "Controls", "extension", "filter", "owner", "patches", "toFilterFn", "_", "GlobalFunctionsAndProps", "all", "dest", "entriesReducer", "accumulator", "key", "entry", "Descriptor", "staticPatchReducer", "patch", "ownerName", "instancePatchReducer", "descriptor", "results", "src_default", "toFilterFn", "filter", "owner", "extension", "filterFn", "elements", "_", "element", "elementStr"]
}

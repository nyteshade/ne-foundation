{
  "version": 3,
  "sources": ["../../src/index.js", "../../src/errors/CannotBeExtendedError.js", "../../src/errors/MissingOwnerValue.js", "../../src/patchtoggle.js", "../../src/patchentry.js", "../../src/patch.js", "../../src/extension.js"],
  "sourcesContent": ["export { Extension } from './extension.js'\nexport { Patch } from './patch.js'\nexport { PatchEntry } from './patchentry.js'\nexport { PatchToggle } from './patchtoggle.js'\n\nimport { CannotBeExtendedError } from './errors/CannotBeExtendedError.js'\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\n\nexport const Errors = {\n  get CannotBeExtended() { return CannotBeExtendedError },\n  get MissingOwnerValue() { return MissingOwnerValue },\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when there is an attempt to extend a\n * restricted part of the code. This error is specifically used to signal\n * violations of extension constraints, such as tampering with certain keys\n * or properties of an object. The error message constructed will include the\n * details of the owner (the restricted part) and the key that was attempted to\n * be tampered with.\n */\nexport class CannotBeExtendedError extends Error {\n  /**\n   * Constructs a new CannotBeExtendedError instance.\n   *\n   * @param {string} owner The name or identifier of the restricted part\n   * that is disallowing extension or tampering.\n   * @param {string} key The key or property that was attempted to be\n   * modified or extended.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} disallows tampering with ${key}.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "/** Small utility to fetch name of class or type */\nconst typeOf = o => /(\\w+)]/.exec(Object.prototype.toString.call(o))[1]\n\n/**\n * Represents an error that is thrown when a property is missing from a specified\n * owner object. This error is used to indicate that a specific key or property\n * expected to be present on the owner is not found, highlighting potential issues\n * in property access or data integrity.\n */\nexport class MissingOwnerValue extends Error {\n  /**\n   * Constructs a new MissingOwnerValue instance.\n   *\n   * @param {string} owner The object or entity that is supposed to contain the\n   * property.\n   * @param {string} key The name of the property that is missing from the owner.\n   */\n  constructor(owner, key) {\n    super(`${typeOf(owner)} does not have a property named '${key}'.`)\n    Object.assign(this, { owner, key })\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Overrides the default\n   * Object.prototype.toString behavior, returning the constructor's name\n   * of this error instance. Useful for debugging and logging purposes.\n   *\n   * @returns {string} The name of the constructor for this error instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n", "import { Patch } from \"./patch\";\n\n/**\n * Early usage of the Patch and Extension classes made it clear that it was\n * cumbersome to use a Patch temporarily for a block of code and excessive\n * amounts of if/else statements were required. This simple wrapper makes that\n * process easier.\n */\nexport class PatchToggle {\n  /**\n   * Wraps an instance of a Patch. It allows low-code clean-readability to\n   * start and stop the underlying patch regardless of whether or not the\n   * patch has been already applied.\n   *\n   * @param {Patch} patch instance of `Patch` to wrap with this toggle\n   * @param {boolean} preventRevert prevents the call to `.revert()` on the\n   * supplied patch when stop() is called.\n   */\n  constructor(patch, preventRevert = false) {\n    this.started = false\n    this.preventRevert = preventRevert\n    this.patch = patch\n    this.patchName = (\n      patch.owner?.name ??\n      patch.owner?.constructor?.name ??\n      /(\\w+)]/.exec(Object.prototype.toString.call(patch.owner))[1]\n    )\n    this.state = {\n      needsApplication: false,\n      needsReversion: false,\n    }\n  }\n\n  /**\n   * If the usage of the wrapped Patch hasn't been started yet, the code checks\n   * whether or not the patch has been applied by checking for signs of it in\n   * the owning object.\n   *\n   * If the patch needs to be applied, it will be applied at this time.\n   *\n   * @returns {PatchToggle} returns `this` to allow for chaining\n   */\n  start() {\n    if (!this.started) {\n      this.state.needsApplication = !this.patch.applied\n      this.state.needsReversion = this.patch.applied\n      this.started = true\n\n      if (this.state.needsApplication) {\n        this.patch.apply()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Checks to see if the toggle has been started. If so, the patch is reverted\n   * if it needed to be applied previously. After stopping, the state of the instance\n   * is reverted to allow for clean subsequent calls to start.\n   *\n   * @returns {PatchToggle} returns `this` to allow further chaining\n   */\n  stop() {\n    if (this.started) {\n      if (this.preventRevert || this.patch.applied) {\n        this.patch.revert()\n      }\n\n      this.state.needsApplication = false\n      this.state.needsReversion = false\n      this.started = false\n    }\n\n    return this\n  }\n\n  /**\n   * When the string tag for this class instance is inspected, it will\n   * reflect the string `PatchToggle:PatchName`\n   */\n  get [Symbol.toStringTag]() {\n    return `${this.constructor.name}:${this.patchName}`\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchToggle instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const objName = this[Symbol.toStringTag]\n    const status = `(started: ${this.started} needed: ${this.state.needsApplication})`\n\n    return inspect(`${objName} ${status}`, {...options, depth})\n  }\n}", "/**\n * A PatchEntry class is a wrapper that maps the descriptor, key and owning\n * object in a single instance. When a Patch or Extension are created, one\n * of these for each patch is created so that the patch can be applied and\n * reverted.\n */\nexport class PatchEntry {\n  /**\n   * Constructs a new PatchEntry instance.\n   *\n   * @param {string|symbol} property The property key to be patched.\n   * @param {object} [owningObject=globalThis] The object from which the\n   * property descriptor is taken.\n   * @param {function} condition if a valid function is passed here, the\n   * expectation is that it takes no parameters and returns a `boolean`. If\n   * `true`, then this entry can be applied. If `false`, it indicates to the\n   * consuming `Patch` that it cannot be applied.\n   * @throws {TypeError} if `owningObject` is not a valid object (i.e. one that\n   * can contain property descriptors and assigned values), then a `TypeError`\n   * is thrown. A `TypeError` is also thrown if `property` is null, or neither\n   * an object nor symbol.\n   */\n  constructor(property, owningObject = globalThis, condition = undefined) {\n    const isNullish = (value) => (value === null || value === undefined)\n    const isKey = (value, types = ['string', 'symbol']) =>\n      !isNullish(value) && (!!types.find(f => f === (typeof value)))\n    const isObject = value => isKey(value, ['object'])\n\n    if (!isKey(property)) {\n      console.error(\n        'Property', property, `(type: ${typeof property})`,\n        'owningObject', owningObject, `(type: ${typeof owningObject})`,\n        'condition', condition, `(type: ${typeof condition})`,\n      )\n      throw new TypeError('Property must be non-null and either a string or symbol')\n    }\n\n    if (!isObject(owningObject)) {\n      throw new TypeError('Cannot create Patch entry as owning object is invalid')\n    }\n\n    Object.assign(this, {\n      key: property,\n      descriptor: Object.getOwnPropertyDescriptor(owningObject, property),\n      owner: owningObject,\n      condition: (typeof condition === 'function') ? condition : undefined\n    })\n  }\n\n  /**\n   * Computes and returns the current value of the patch, based on its type\n   * (data or accessor).\n   *\n   * @returns {any} The current value of the patch.\n   */\n  get computed() {\n    if (this.isAccessor) {\n      return this.descriptor.get.bind(this.owner).call()\n    }\n    else {\n      return this.descriptor.value\n    }\n  }\n\n  /**\n   * Checks if the patch is a data property (has a value).\n   *\n   * @returns {boolean} True if the patch is a data property, false otherwise.\n   */\n  get isData() {\n    return Reflect.has(this.descriptor, 'value')\n  }\n\n  /**\n   * Checks if the patch is an accessor property (has a getter).\n   *\n   * @returns {boolean} True if the patch is an accessor property, false otherwise.\n   */\n  get isAccessor() {\n    return Reflect.has(this.descriptor, 'get')\n  }\n\n  /**\n   * Checks if the patch is read-only (not configurable or not writable).\n   *\n   * @returns {boolean} True if the patch is read-only, false otherwise.\n   */\n  get isReadOnly() {\n    return (\n      (Reflect.has(this.descriptor, 'configurable') && !this.descriptor.configurable) ||\n      (Reflect.has(this.descriptor, 'writable') && !this.descriptor.writable)\n    )\n  }\n\n  /**\n   * If a `condition` is associated with this specific patch entry, then it will\n   * run and its result will be returned. Otherwise `true` is returned allowing\n   * all non-conditional `PatchEntry` instances to be applied every time.\n   *\n   * @returns {boolean} `true` if the condition is true or there is no condition\n   * applied to this instance. `false` if the condition fails.\n   */\n  get isAllowed() {\n    const validAndPresent = (\n      this.condition &&\n      typeof this.condition === 'function'\n    )\n\n    return validAndPresent ? this.condition() : true\n  }\n\n  /**\n   * Applies the patch entry to a given object. This method takes the\n   * descriptor from the current patch entry and defines it on the target\n   * object. If `bindAccessors` is true and the descriptor contains accessor\n   * methods (getters/setters), they will be bound to the original owner of\n   * the patch before being applied to ensure the correct `this` context.\n   *\n   * @param {object} anotherObject - The object to which the patch will be \n   * applied.\n   * @param {boolean} [bindAccessors=false] - Whether to bind accessor methods \n   * to the patch's owner.\n   */\n  applyTo(anotherObject, bindAccessors = false) {\n    const descriptor = { ...this.descriptor }\n\n    if (bindAccessors) {\n      if (typeof descriptor.get === 'function') {\n        descriptor.get = descriptor.get.bind(this.owner);\n      }\n      if (typeof descriptor.set === 'function') {\n        descriptor.set = descriptor.set.bind(this.owner);\n      }\n    }\n\n    Object.defineProperty(anotherObject, this.key, descriptor);\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name of\n   * the PatchEntry instance.\n   *\n   * @returns {string} The class name of the PatchEntry instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the PatchEntry instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the PatchEntry instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const type = this.isData ? ' Data' : ' Accessor'\n    const writable = this.isReadOnly ? ' [ReadOnly]' : ''\n\n    return `PatchEntry<${this.key}${type}${writable}>`\n  }\n}\n", "import { PatchToggle } from './patchtoggle.js'\nimport { PatchEntry } from './patchentry.js'\n\n/**\n * The Patch class provides a mechanism to apply patches to properties or\n * methods of an object (the owner). It keeps track of the original state of\n * these properties and allows for the application and reversion of patches.\n */\nexport class Patch {\n  /**\n   * A record of conflicts between existing and patched properties or methods.\n   * This object maps property names to their respective PatchEntry instances,\n   * which contain information about the original and patched values.\n   *\n   * @type {object}\n   */\n  patchConflicts = {}\n\n  /**\n   * An object to store patch entries. Each key corresponds to a property or\n   * method name on the owner object, and the value is the associated\n   * PatchEntry instance which contains the patched and original values.\n   *\n   * @type {object}\n   */\n  patchEntries = {}\n\n  /**\n   * The object containing the patches to be applied to the owner. It is\n   * initially undefined and will be populated with the patches passed to the\n   * constructor.\n   *\n   * @type {object}\n   */\n  patchesOwner = undefined\n\n  /**\n   * The count of patches that have been applied. This is incremented\n   * each time a patch is applied and decremented when a patch is\n   * reverted.\n   *\n   * @type {number}\n   */\n  patchCount = 0\n\n  /**\n   * The number of patches that have been successfully applied. This count\n   * is incremented after each successful patch application and decremented\n   * when a patch is reverted.\n   *\n   * @type {number}\n   */\n  patchesApplied = 0\n\n  /**\n   * Constructs a new Patch instance. Supported options for Patch instances\n   * include either a global condition for the Patch to be applied or\n   * specific property conditions subjecting only a subset of the patches\n   * to conditional application.\n   *\n   * @example\n   * ```\n   * const custom = Symbol.for('nodejs.util.inspect.custom')\n   * const patch = new Patch(\n   *   Object,\n   *   {\n   *     property: 'value',\n   *     [custom](depth, options, inspect) {\n   *       // ... custom return string for nodejs\n   *     }\n   *   },\n   *   {\n   *     conditions: {\n   *       [custom]() { return process?.versions?.node !== null },\n   *     },\n   *   }\n   * )\n   * patch.apply() // applies `property` but only applies the `custom`\n   *               // property if the JavaScript is running in NodeJS\n   * ```\n   *\n   * @param {object} owner The object to which patches will be applied.\n   * @param {object} patches An object containing properties or methods to\n   *                         be patched onto the owner.\n   * @param {object} [options={}] Additional options for patching behavior.\n   */\n  constructor(owner, patches, options = {}) {\n    Object.assign(this, {\n      owner,\n      options,\n    })\n\n    this.patchesOwner = patches\n\n    const globalCondition = this?.options.condition\n\n    Reflect.ownKeys(patches).forEach(key => {\n      const condition = this?.options?.conditions?.[key] ?? globalCondition\n      try {\n        this.patchEntries[key] = new PatchEntry(key, this.patchesOwner, condition)\n        this.patchCount += 1\n      }\n      catch (error) {\n        console.error(`Failed to process patch for ${key}\\n`, error)\n      }\n\n      if (Reflect.has(this.owner, key)) {\n        try {\n          this.patchConflicts[key] = new PatchEntry(key, this.owner)\n        }\n        catch (error) {\n          console.error(`Cannot capture conflicting patch key ${key}\\n`, error)\n        }\n      }\n    })\n\n    if (!Patch.patches.has(owner)) {\n      Patch.patches.set(owner, [])\n    }\n\n    Patch.patches.get(owner).push(this)\n  }\n\n  /**\n   * Retrieves the patch entries as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get entries() {\n    return Reflect.ownKeys(this.patchEntries).map(key => {\n      return [key, this.patchEntries[key]]\n    })\n  }\n\n  /**\n   * Retrieves an array of patch entries that have been successfully applied.\n   * Each entry is a key-value pair array where the key is the patch identifier\n   * and the value is the corresponding `PatchEntry` object. Only patches with\n   * a state of `true` in `patchState` are included, indicating they are\n   * currently applied to the owner object.\n   *\n   * @returns {Array} An array of [key, patchEntry]\n   * pairs representing the applied patches.\n   */\n  get appliedEntries() {\n    return Reflect.\n      ownKeys(this.patchEntries).\n      filter(key => this.patchState.get(key) === true).\n      map(key => {\n        return [key, this.patchEntries[key]]\n      })\n  }\n\n  /**\n   * Retrieves an array of patch entries that have not been applied. Each entry\n   * is a key-value pair array where the key is the patch identifier and the\n   * value is the corresponding `PatchEntry` object. Only patches with a state\n   * of `false` in `patchState` are included, indicating they are not currently\n   * applied to the owner object.\n   *\n   * @returns {Array} An array of [key, patchEntry]\n   * pairs representing the unapplied patches.\n   */\n  get unappliedEntries() {\n    return Reflect.\n      ownKeys(this.patchEntries).\n      filter(key => this.patchState.get(key) === false).\n      map(key => {\n        return [key, this.patchEntries[key]]\n      })\n  }\n\n  /**\n   * Depending on how the PatchEntry is configured, accessing the patch\n   * by name can be somewhat irritating, so this provides an object with\n   * the actual current patch value at the time patchValues is requested.\n   *\n   * @example let { patch1, patch2 } = patch.patchValues\n   * @returns {object} an object with the patchName mapped to the current\n   * computed patchEntry value.\n   */\n  get patches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      acc[key] = patchEntry.computed\n      return acc\n    }, {})\n  }\n\n  /**\n   * Retrieves an object containing all patches that have been successfully\n   * applied. The object's keys are the patch keys, and the values are the\n   * computed values of the corresponding patch entries. Only patches with\n   * a state of `true` in `patchState` are considered applied.\n   *\n   * @returns {object} An object mapping each applied patch key to its\n   * computed value.\n   */\n  get appliedPatches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      if (this.patchState.get(key) === true) {\n        acc[key] = patchEntry.computed\n      }\n      return acc\n    }, {})\n  }\n\n  /**\n   * Retrieves an object containing all patches that have not been applied.\n   * The object's keys are the patch keys, and the values are the computed\n   * values of the corresponding patch entries. Only patches with a state\n   * of `false` in `patchState` are considered unapplied.\n   *\n   * @example\n   * // Assuming `patch` is an instance of `Patch` and `patch1` is unapplied:\n   * let unapplied = patch.unappliedPatches;\n   * console.log(unapplied); // { patch1: computedValueOfPatch1 }\n   *\n   * @returns {object} An object mapping each unapplied patch key to its\n   * computed value.\n   */\n  get unappliedPatches() {\n    return this.entries.reduce((acc, [key, patchEntry]) => {\n      if (this.patchState.get(key) === false) {\n        acc[key] = patchEntry.computed\n      }\n      return acc\n    }, {})\n  }\n\n  /**\n   * Retrieves an array of patch keys.\n   *\n   * This getter returns an array containing only the keys of the patch entries,\n   * which can be useful for iterating over the patches or checking for the\n   * existence of specific patches by key.\n   *\n   * @returns {string[]} An array of patch keys.\n   */\n  get patchKeys() {\n    return this.entries.map(([key, _]) => key)\n  }\n\n  /**\n   * Retrieves the conflict entries (existing properties on the owner that\n   * will be overridden by patches) as an array of [key, patchEntry] pairs.\n   *\n   * @returns {Array} An array of [key, patchEntry] pairs.\n   */\n  get conflicts() {\n    return Reflect.ownKeys(this.patchConflicts).map(key => {\n      return [key, this.patchConflicts[key]]\n    })\n  }\n\n  /**\n   * Checks to see if the tracked number of applied patches is greater than 0\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get applied() {\n    return this.patchesApplied > 0\n  }\n\n  /**\n   * Provided for semantics, but this method is synonymous with {@link applied}.\n   *\n   * @returns {boolean} true if at least one patch has been applied\n   */\n  get isPartiallyPatched() {\n    return this.applied\n  }\n\n  /**\n   * Returns true only when the number of tracked patches matches the number\n   * of applied patches.\n   *\n   * @returns {boolean} true if applied patches is equal to the count of patches\n   */\n  get isFullyPatched() {\n    return this.patchCount == this.patchesApplied\n  }\n\n  /**\n   * Applies all patches to the owner object. If a property with the same key\n   * already exists on the owner, it will be overridden. Optionally a callback\n   * can be supplied to the call to revert. If the callback is a valid function,\n   * it will be invoked with an object containing the results of the reversion\n   * of the patch. The callback receives a single parameter which is an object\n   * of counts. It has the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   applied: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   notApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `applied` is the number of patches that were applied\n   * 'errors' is an array of arrays where the first element is the `PatchEntry`\n   * and the second element is an `Error` indicating the problem. An error will\n   * only be generated if `isAllowed` is `true` and the patch still failed to\n   * apply Lastly `notApplied` is the number of patches that were unable to\n   * be applied.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === applied when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 notApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  apply(metrics) {\n    const entries = this.entries\n    const counts = {\n      patches: entries.length,\n      applied: 0,\n      errors: [],\n      notApplied: entries.length,\n    }\n\n    this.patchState.clear()\n\n    entries.forEach(([,patch]) => {\n      if (patch.isAllowed) {\n        // Patch\n        Object.defineProperty(this.owner, patch.key, patch.descriptor)\n\n        // Verify\n        let oDesc = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n        if (this.#equalDescriptors(oDesc, patch.descriptor)) {\n          counts.applied += 1\n          counts.notApplied -= 1\n\n          this.patchState.set(patch, true)\n\n        }\n        else {\n          counts.errors.push([patch, new Error(\n            `Could not apply patch for key ${patch.key}`\n          )])\n          this.patchState.set(patch, false)\n        }\n      }\n      else {\n        this.patchState.set(patch, false)\n      }\n    })\n\n    this.patchesApplied = counts.applied\n\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Creates an easy to use toggle for working with `Patch` classes\n   *\n   * @param {boolean} preventRevert true if calling stop() on the toggle does not\n   * revert the patch. false, the default, if it should.\n   * @returns {PatchToggle} an instance of PatchToggle wrapped around this instance\n   * of `Patch`\n   * @example const toggle = ObjectExtensions.createToggle().start()\n   */\n  createToggle(preventRevert = false) {\n    return new PatchToggle(this, preventRevert)\n  }\n\n  /**\n   * Reverts all applied patches on the owner object, restoring any overridden\n   * properties to their original state. Optionally a callback can be supplied to\n   * the call to revert. If the callback is a valid function, it will be invoked\n   * with an object containing the results of the reversion of the patch. The\n   * callback receives a single parameter which is an object of counts. It has\n   * the signature:\n   *\n   * ```\n   * type counts = {\n   *   patches: number;\n   *   reverted: number;\n   *   restored: number;\n   *   conflicts: number;\n   *   errors: Array<PatchEntry,Error>;\n   *   stillApplied: number;\n   * }\n   * ```\n   *\n   * While the keys may be obvious to some, `patches` is the count of patches\n   * this instance tracks. `reverted` is the number of patches that were removed'\n   * `restored` is the number of originally conflicting keys that were restored.\n   * `conflicts` is the total number of conflicts expected. `errors` is an array of\n   * arrays where the first element is the `PatchEntry` and the second element\n   * is an `Error` indicating the problem. Lastly `stillApplied` is the number of\n   * patchesApplied still tracked. If this is greater than zero, you can assume\n   * something went wrong.\n   *\n   * Additional logic that should track\n   * ```\n   *   \u2022 patches should === reverted when done\n   *   \u2022 restored should === conflicts when done\n   *   \u2022 errors.length should be 0 when done\n   *   \u2022 stillApplied should be 0 when done\n   * ```\n   *\n   * @param {function} metrics - a callback which receives a status of the\n   * `revert` action if supplied. This callback will not be invoked, nor will\n   * any of the other logic be captured, if {@link applied} returns false\n   */\n  revert(metrics) {\n    if (!this.applied) {\n      return\n    }\n\n    const entries = this.entries\n    const conflicts = this.conflicts\n\n    const counts = {\n      patches: entries.length,\n      reverted: 0,\n      restored: 0,\n      conflicts: conflicts.length,\n      errors: [],\n      stillApplied: 0,\n    }\n\n    entries.forEach(([,patch]) => {\n      const successful = delete this.owner[patch.key]\n      if (successful) {\n        this.patchesApplied -= 1\n        counts.reverted += 1\n        this.patchState.set(patch, false)\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to revert patch ${patch.key}`\n        )])\n      }\n    })\n\n    conflicts.forEach(([,patch]) => {\n      Object.defineProperty(this.owner, patch.key, patch.descriptor)\n      const appliedDescriptor = Object.getOwnPropertyDescriptor(this.owner, patch.key)\n      if (this.#equalDescriptors(patch.descriptor, appliedDescriptor)) {\n        counts.restored += 1\n      }\n      else {\n        counts.errors.push([patch, new Error(\n          `Failed to restore original ${patch.key}`\n        )])\n      }\n    })\n\n    counts.stillApplied = this.patchesApplied\n    if (typeof metrics === 'function') {\n      metrics(counts)\n    }\n  }\n\n  /**\n   * Removes this Patch instance from being tracked amongst all the tracked Patch\n   * instances. The JavaScript virtual machine will clean this instance up once\n   * nothing else is holding a reference to it.\n   */\n  release() {\n    const patches = Patch.patches.get(this.owner)\n    patches.splice(patches.find(e => e === this), 1)\n  }\n\n  /**\n   * The object to which the patches are applied.\n   */\n  owner = null;\n\n  /**\n   * Additional options for patching behavior.\n   */\n  options = null;\n\n  /**\n   * Patches that are currently live and active will have true as their\n   * value and inert or non-applied patches will have false as their\n   * value. The key is always the associated {@link PatchEntry}.\n   */\n  patchState = new Map();\n\n  /**\n   * Creates an iterator for the patch entries, allowing the `Patch` instance to\n   * be directly iterable using a `for...of` loop. Each iteration will yield a\n   * `[key, patchEntry]` pair, where `key` is the property name and `patchEntry`\n   * is the corresponding `PatchEntry` instance.\n   *\n   * @returns {Iterator} An iterator that yields `[key, patchEntry]` pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries.values()\n  }\n\n  /**\n   * Compares two property descriptor objects to determine if they are equivalent.\n   *\n   * This method checks if both descriptors have the same value for the\n   * `configurable`, `enumerable`, `value`, `writable`, `get`, and `set`\n   * properties. If any of these properties differ between the two descriptors,\n   * the descriptors are considered not equivalent.\n   *\n   * @param {PropertyDescriptor} left - The first descriptor to compare.\n   * @param {PropertyDescriptor} right - The second descriptor to compare.\n   * @returns {boolean} - True if the descriptors are equivalent, false otherwise.\n   * @private\n   */\n  #equalDescriptors(left, right) {\n    if (!left || !right) {\n      return false;\n    }\n\n    return (\n      left.configurable === right.configurable &&\n      left.enumerable === right.enumerable &&\n      left.value === right.value &&\n      left.writable === right.writable &&\n      left.get === right.get &&\n      left.set === right.set\n    )\n  }\n\n  /**\n   * Custom inspection function for Node.js that is called when `util.inspect`\n   * is used to convert the instance to a string. This allows for customizing\n   * the output of `util.inspect` for objects of this class.\n   *\n   * @param {number} depth The current depth of the inspection. If the depth\n   * is less than the recurse times set, it will return the object itself,\n   * otherwise it will return the inspected result.\n   * @param {object} options An object containing options for the inspection.\n   * @param {function} inspect The inspection function provided by Node.js\n   * that can be called to inspect other properties with the same options as\n   * the original call.\n   * @returns {string} A string representation of the instance tailored for\n   * Node.js' `util.inspect`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const exprs = {\n      get quotes() { return /^(\\x1B\\[\\d+m)?['\"]|[\"'](\\x1B\\[\\d+m)?$/g },\n      get arrays() { return /^(\\x1B\\[\\d+m)?\\[ | \\](\\x1B\\[\\d+m)?$/g },\n    }\n    const opts = { ...options, depth };\n    const type = this.owner?.name ?? ''\n    const name = (type.length\n      ? `[${inspect(type, options).replaceAll(exprs.quotes, '$1$2')}]`\n      : ''\n    )\n    const keys = (\n      inspect(this.patchKeys, opts)\n        .replaceAll(exprs.arrays, '$1$2')\n        .replaceAll(/'(.*?)'/g, \"$1\")\n    )\n    return `${this.constructor.name}${name} { ${keys} }`;\n  }\n\n  /**\n   * A global mapping of all patches in play\n   */\n  static patches = new Map()\n\n  /**\n   * Applies all patches associated with a given owner object. This method\n   * is used to enable all patches for a specific owner if they have been\n   * previously registered.\n   *\n   * @param {object} owner The object whose patches are to be applied.\n   */\n  static enableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.apply()\n      }\n    }\n  }\n\n  /**\n   * Reverts all patches associated with a given owner object. This method\n   * is used to disable all patches for a specific owner if they have been\n   * previously applied.\n   *\n   * @param {object} owner The object whose patches are to be reverted.\n   */\n  static disableFor(owner) {\n    if (Patch.patches.has(owner)) {\n      for (const patch of Patch.patches.get(owner)) {\n        patch.revert()\n      }\n    }\n  }\n\n  /**\n   * A static getter that provides a proxy to manage and interact with the\n   * patches that have been applied globally. This proxy abstracts the\n   * underlying details and presents a simplified interface for querying and\n   * manipulating applied patches. It is particularly useful in IDEs, as it\n   * allows developers to access the state of applied patches without needing\n   * to delve into the source code.\n   *\n   * @returns {Object} An object showing all the keys known to be patched for\n   * the default owner, `globalThis`\n   */\n  static get applied() {\n    return this.#allPatchesForOwner(globalThis, true)\n  }\n\n  /**\n   * A static getter that provides access to a proxy representing all known\n   * patches, whether applied or not. This is useful for inspecting the\n   * complete set of patches that have been registered in the system, without\n   * limiting the view to only those that are currently active. The proxy\n   * abstracts the underlying details and presents a simplified interface for\n   * querying and manipulating the patches.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of all\n   * registered patches, allowing for operations like checking if a patch is\n   * known and retrieving patch values.\n   */\n  static get known() {\n    return this.#allPatchesForOwner(globalThis, false)\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with a toggle functionality. This proxy allows the temporary\n   * application of patches within a certain scope, and automatically reverts\n   * them after the scope ends. It is useful for applying patches in a\n   * controlled manner, ensuring that they do not remain active beyond the\n   * intended usage.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with toggle functionality, allowing for temporary application\n   * and automatic reversion of patches.\n   */\n  static get use() {\n    return this.#allPatchesForOwner(globalThis, false, true)\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with lazy initialization. This proxy defers the creation and\n   * application of patches until they are explicitly requested. It is\n   * beneficial for performance optimization, as it avoids the overhead of\n   * initializing patches that may not be used.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with lazy initialization, allowing patches to be created and\n   * applied only when needed.\n   */\n  static get lazy() {\n    return this.#allPatchesForOwner(globalThis, false, false, true)\n  }\n\n  /**\n   * Returns an object with getters to access different proxy views of patches\n   * scoped to a specific owner. This allows for interaction with patches\n   * that are either applied, known, or used within a certain scope, providing\n   * a controlled environment for patch management.\n   *\n   * @param {object} owner - The object to scope the patch proxies to.\n   * @returns {object} An object containing getters for `applied`, `known`,\n   * and `use` proxies:\n   * - `applied`: Proxy for patches applied to the owner.\n   * - `known`: Proxy for all patches known to the owner, applied or not.\n   * - `use`: Proxy that allows temporary application of patches.\n   */\n  static scopedTo(owner) {\n    const allForOwner = (\n      owner,\n      appliedOnly,\n      wrapInToggle = false,\n      applyOnRequest = false\n    ) => {\n      return this.#allPatchesForOwner(\n        owner,\n        appliedOnly,\n        wrapInToggle,\n        applyOnRequest\n      )\n    }\n\n    return {\n      /**\n       * Getter for a proxy that represents patches applied to the owner.\n       * This proxy provides a simplified interface for interacting with\n       * applied patches, such as checking their status or retrieving values.\n       *\n       * @returns {Proxy} A proxy to the applied patches.\n       */\n      get applied() {\n        return allForOwner(owner, true, false)\n      },\n\n      /**\n       * Getter for a proxy that represents all patches known to the owner,\n       * whether they are applied or not. This proxy allows for querying\n       * and manipulation of the patches without directly accessing them.\n       *\n       * @returns {Proxy} A proxy to all known patches.\n       */\n      get known() {\n        return allForOwner(owner, false, false)\n      },\n\n      /**\n       * Getter for a proxy that enables temporary application of patches\n       * within a certain scope. The patches are automatically reverted\n       * after the scope ends, ensuring controlled usage.\n       *\n       * @returns {Proxy} A proxy to patches with toggle functionality.\n       */\n      get use() {\n        return allForOwner(owner, false, true)\n      },\n\n      /**\n       * Getter for a proxy that represents patches that are not immediately\n       * applied but are applied on request. This allows for patches to be\n       * applied only when they are explicitly needed, potentially improving\n       * performance by deferring the application of patches until necessary.\n       *\n       * @returns {Proxy} A proxy to patches that are applied on request.\n       */\n      get lazy() {\n        return allForOwner(owner, false, false, true)\n      },\n    }\n  }\n\n  /**\n   * Aggregates patches for a given owner into a single object, optionally\n   * filtering by applied status and wrapping in a toggle function.\n   *\n   * This method collects all patches associated with the specified owner\n   * and constructs an object where each patch is represented by its key.\n   * If `onlyApplied` is true, only patches that are currently applied will\n   * be included. If `wrapInToggle` is true, each patch will be represented\n   * as a function that temporarily applies the patch when called.\n   *\n   * @param {object} owner - The owner object whose patches are to be\n   * aggregated.\n   * @param {boolean} onlyApplied - If true, only include patches that\n   * are applied.\n   * @param {boolean} [wrapInToggle=false] - If true, wrap patches in a\n   * toggle function for temporary application.\n   * @returns {object} An object representing the aggregated patches, with\n   * each patch keyed by its property name.\n   * @private\n   */\n  static #allPatchesForOwner(\n    owner,\n    onlyApplied,\n    wrapInToggle = false,\n    applyOnRequest = false\n  ) {\n    return [...Patch.patches.values()].\n      flat().\n      filter(patch => patch.owner === owner).\n      reduce((accumulator, patch) => {\n        for (const [,patchEntry] of patch.entries) {\n          if (onlyApplied && patch.patchState.get(patchEntry) !== true) {\n            continue\n          }\n\n          if (wrapInToggle) {\n            accumulator[patchEntry.key] = async (usage) => {\n              if (typeof usage !== 'function') {\n                return\n              }\n\n              const type = Object.prototype.toString.call(usage)\n              const toggle = patch.createToggle()\n\n              toggle.start()\n              if('[object AsyncFunction]' === type) {\n                await usage(patchEntry.computed, patchEntry)\n              }\n              else {\n                usage(patchEntry.computed, patchEntry)\n              }\n              toggle.stop()\n            }\n\n            continue\n          }\n\n          if (applyOnRequest) {\n            Object.defineProperty(accumulator, patchEntry.key, {\n              get() {\n                patch.apply()\n                return patchEntry.computed\n              },\n              enumerable: true,\n              configurable: true,\n            });\n\n            continue;\n          }\n\n\n          if (patchEntry.isAccessor) {\n            let dynName = `applyAccessorFor_${String(patchEntry.key)}`\n            let dynNameContainer = {\n              [dynName](applyTo) {\n                patchEntry.applyTo(applyTo)\n                return applyTo\n              }\n            };\n\n            accumulator[patchEntry.key] = dynNameContainer[dynName]\n          }\n          else {\n            patchEntry.applyTo(accumulator)\n          }\n        }\n\n        return accumulator\n      }, {})\n  }\n\n  /**\n   * A getter for the custom inspect symbol used by Node.js.\n   *\n   * @returns {symbol} The custom inspect symbol.\n   */\n  static get CustomInspect() {\n    return Symbol.for('nodejs.util.inspect.custom')\n  }\n\n  /**\n   * Strips leading and trailing control characters, brackets, braces, and\n   * quotes from a string. This is typically used to clean strings that may\n   * have special characters or escape sequences that are not desired in the\n   * output.\n   *\n   * @param {string} fromString The string to be stripped of extras.\n   * @returns {string} The cleaned string with extras stripped.\n   */\n  static stripExtras(fromString) {\n    return fromString\n      .replaceAll(\n        /^(\\x1B\\[\\d+m)?[\\[\\{]\\s?|\\s?[\\]\\}](\\x1B\\[\\d+m)?$/gm,\n        '$1$2'\n      )\n      .replaceAll(\n        /['\"](.*?)['\"]/gm,\n        '$1'\n      )\n  }\n}", "import { CannotBeExtendedError } from \"./errors/CannotBeExtendedError.js\"\nimport { MissingOwnerValue } from './errors/MissingOwnerValue.js'\nimport { Patch } from './patch.js'\n\n/** Shared array of primitive types for use with `isPrimitive` */\nconst primitives = ['number', 'boolean', 'bigint', 'string', 'symbol']\n\n/**\n * The Extension class, inheriting from the Patch class, is specifically designed\n * for extending properties or methods of a given object. It facilitates the\n * extension process by determining the target key and value for the extension and\n * ensuring the target property is writable and configurable. If these conditions\n * are not met, the class throws a CannotBeExtendedError. This class is useful\n * in scenarios like testing, dynamic behavior adjustments, or managing complex\n * object configurations.\n */\nexport class Extension extends Patch {\n  /**\n   * Constructs a new Extension instance. This constructor initializes the extension\n   * by determining the target key and value for the extension and ensuring that\n   * the property to be extended is configurable and writable. It throws an error\n   * if these conditions are not satisfied. The constructor leverages the Patch\n   * class's functionalities to manage the extension effectively.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function to be\n   * used for the extension. If a function or class is provided, its name is used\n   * as the key.\n   * @param {*} value - The value or method to be used for the extension.\n   * @param {object} [owner=globalThis] - The object to which the extension will\n   * be applied.\n   * @param {object} [options={}] - Additional options for the extension behavior.\n   * @throws {CannotBeExtendedError} If the target property is not writable or\n   * configurable.\n   * @throws {MissingOwnerValue} If the `keyClassOrFn` value is null or there\n   * is an error determining the key and extension values, MissingOwnerValue is\n   * thrown.\n   */\n  constructor(keyClassOrFn, value, owner = globalThis, options = {}) {\n    const metadata = Extension.determineInput(keyClassOrFn)\n    let { key, extension, valid } = metadata\n    extension = value || extension\n\n    if (!valid) {\n      throw new MissingOwnerValue(owner, key)\n    }\n\n    const descriptor = Object.getOwnPropertyDescriptor(owner, key)\n    if (descriptor) {\n      if (\n        (Reflect.has(descriptor, 'writable') && !descriptor.writable) ||\n        (Reflect.has(descriptor, 'configurable') && !descriptor.configurable)\n      ) {\n        throw new CannotBeExtendedError(owner, key)\n      }\n    }\n\n    super(owner, { [key]: extension }, options)\n    this.key = key\n\n    this.class = metadata.class\n    this.function = metadata.function\n  }\n\n  /**\n   * Returns true if this `Extension` represents a `function`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a `function`, or\n   * `false` if it does not\n   */\n  get isFunction() { return !!(this.function) }\n\n  /**\n   * Returns true if this `Extension` represents a `class`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a `class`, or\n   * `false` if it does not\n   */\n  get isClass() { return !!(this.class) }\n\n  /**\n   * Returns true if this `Extension` represents a `primitive`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a\n   * primitive value or `false` if it does not.\n   */\n  get isPrimitive() {\n    return ~primitives.indexOf(typeof this.value)\n  }\n\n  /**\n   * Returns true if this `Extension` represents a value that is not\n   * coerced into an `Object` wrapper when wrapped with `Object(value)`\n   *\n   * @returns {boolean} `true` if this `Extension` introduces a value\n   * that is alrady an `object`, `false` otherwise.\n   */\n  get isObject() {\n    return Object(this.value) === this.value\n  }\n\n  /**\n   * A static getter that provides a proxy to manage and interact with the\n   * patches that have been applied globally. This proxy abstracts the\n   * underlying details and presents a simplified interface for querying and\n   * manipulating applied patches. It is particularly useful in IDEs, as it\n   * allows developers to access the state of applied patches without needing\n   * to delve into the source code.\n   *\n   * @returns {Object} An object showing all the keys known to be patched for\n   * the default owner, `globalThis`\n   */\n  static get applied() {\n    return Patch.applied;\n  }\n\n  /**\n   * A static getter that provides access to a proxy representing all known\n   * patches, whether applied or not. This is useful for inspecting the\n   * complete set of patches that have been registered in the system, without\n   * limiting the view to only those that are currently active. The proxy\n   * abstracts the underlying details and presents a simplified interface for\n   * querying and manipulating the patches.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of all\n   * registered patches, allowing for operations like checking if a patch is\n   * known and retrieving patch values.\n   */\n  static get known() {\n    return Patch.known;\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with a toggle functionality. This proxy allows the temporary\n   * application of patches within a certain scope, and automatically reverts\n   * them after the scope ends. It is useful for applying patches in a\n   * controlled manner, ensuring that they do not remain active beyond the\n   * intended usage.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with toggle functionality, allowing for temporary application\n   * and automatic reversion of patches.\n   */\n  static get use() {\n    return Patch.use;\n  }\n\n  /**\n   * A static getter that provides access to a proxy for managing patch\n   * entries with lazy initialization. This proxy defers the creation and\n   * application of patches until they are explicitly requested. It is\n   * beneficial for performance optimization, as it avoids the overhead of\n   * initializing patches that may not be used.\n   *\n   * @returns {Proxy} A proxy object that represents a virtual view of the\n   * patches with lazy initialization, allowing patches to be created and\n   * applied only when needed.\n   */\n  static get lazy() {\n    return Patch.lazy;\n  }\n\n\n  /**\n   * Returns an object with getters to access different proxy views of patches\n   * scoped to a specific owner. This allows for interaction with patches\n   * that are either applied, known, or used within a certain scope, providing\n   * a controlled environment for patch management.\n   *\n   * @param {object} owner - The object to scope the patch proxies to.\n   * @returns {object} An object containing getters for `applied`, `known`,\n   * and `use` proxies:\n   * - `applied`: Proxy for patches applied to the owner.\n   * - `known`: Proxy for all patches known to the owner, applied or not.\n   * - `use`: Proxy that allows temporary application of patches.\n   */\n  static scopedTo(owner) {\n    return Patch.scopedTo(owner);\n  }\n\n  /**\n   * Determines the input type for the extension. This method processes the input\n   * and identifies the key for the extension and the associated value or method.\n   * It supports inputs as either a string key or a function/class, providing\n   * flexibility in defining extensions.\n   *\n   * @param {Function|string} keyClassOrFn - The key, class, or function provided\n   * as input. If a function or class is provided, its name is used as the key.\n   * containing the determined key, the extension value/method, and a validity flag\n   * indicating whether the input is usable.\n   * @returns {{key: string|null, extension: *|null, valid: boolean}} An object\n   */\n  static determineInput(keyClassOrFn) {\n    let input = { key: null, extension: null, valid: false }\n\n    if (keyClassOrFn instanceof Function) {\n      input = {\n        key: keyClassOrFn.name,\n        extension: keyClassOrFn,\n        valid: true\n      }\n\n      if (/^class .*/.exec(keyClassOrFn.toString())) {\n        input.class = keyClassOrFn\n      }\n\n      if (/^(async )?function .*/.exec(keyClassOrFn.toString())) {\n        input.function = keyClassOrFn\n      }\n    }\n    else if (typeof keyClassOrFn === 'string' || keyClassOrFn instanceof String) {\n      input = { key: keyClassOrFn, extension: null, valid: true }\n    }\n\n    return input\n  }\n\n  /**\n   * Custom inspect function for Node.js that provides a formatted representation\n   * of the Extension instance, primarily for debugging purposes.\n   *\n   * @param {number} depth The depth to which the object should be formatted.\n   * @param {object} options Formatting options.\n   * @param {function} inspect The inspection function to format the object.\n   * @returns {string} A formatted string representing the Extension instance.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n    const exprs = {\n      get braces() { return /^(\\x1B\\[\\d+m)?[\\[\\{]|[\\]\\}](\\x1B\\[\\d+m)?$/g },\n      get quotes() { return /^(\\x1B\\[\\d+m)?['\"]|[\"'](\\x1B\\[\\d+m)?$/g },\n    }\n\n    const key = inspect(this.key, options).replaceAll(exprs.quotes, '$1$2')\n    const val = (\n      inspect(this.patches[this.key], options)\n      .replaceAll(exprs.braces, '$1$2')\n    )\n\n    return `Extension[${key}:${val}]`\n  }\n\n  /**\n   * Custom getter for the toStringTag symbol. Provides the class name when the\n   * object is converted to a string, typically used for debugging and logging.\n   *\n   * @returns {string} The class name of the Extension instance.\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Creates a new ExtensionSet with the provided name and extensions.\n   *\n   * @param {string} name - The name of the extension set.\n   * @param {...Extension|Function} extensions - A list of extensions or\n   * functions to include in the set.\n   * @returns {ExtensionSet} A new instance of ExtensionSet containing the\n   * given extensions.\n   */\n  static createSet(name, ...extensions) {\n    return new Extension.ExtensionSet(name, ...extensions)\n  }\n\n  /**\n   * Represents a set of extensions.\n   */\n  static ExtensionSet = class ExtensionSet {\n    /**\n     * Creates an instance of ExtensionSet.\n     *\n     * @param {string} name - The name of the extension set.\n     * @param {...(Extension|Function)} extensions - Extensions or functions to\n     * add to the set.\n     */\n    constructor(name, ...extensions) {\n      this.name = name;\n      this.extensionObjects = new Set();\n      this.extensions = new Set();\n\n      for (const extensionValue of extensions) {\n        if (extensionValue instanceof Extension) {\n          this.extensions.add(extensionValue);\n          this.extensionObjects.add(extensionValue.patches[extensionValue.key]);\n        } else if (extensionValue instanceof Function) {\n          this.extensionObjects.add(extensionValue);\n          this.extensions.add(new Extension(extensionValue));\n        }\n      }\n    }\n\n    /**\n     * Applies all extensions in the set.\n     */\n    apply() {\n      for (const extension of this.extensions) {\n        extension.apply();\n      }\n    }\n\n    /**\n     * Reverts all extensions in the set.\n     */\n    revert() {\n      for (const extension of this.extensions) {\n        extension.revert();\n      }\n    }\n  }\n}"],
  "mappings": "obAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,YAAAE,EAAA,cAAAC,EAAA,UAAAC,EAAA,eAAAC,EAAA,gBAAAC,ICCA,IAAMC,EAAS,GAAK,SAAS,KAAK,OAAO,UAAU,SAAS,KAAK,CAAC,CAAC,EAAE,CAAC,EAUzDC,EAAN,cAAoC,KAAM,CAS/C,YAAYC,EAAOC,EAAK,CACtB,MAAM,GAAGH,EAAOE,CAAK,CAAC,6BAA6BC,CAAG,GAAG,EACzD,OAAO,OAAO,KAAM,CAAE,MAAAD,EAAO,IAAAC,CAAI,CAAC,CACpC,CAQA,IAAK,OAAO,WAAW,GAAI,CACzB,OAAO,KAAK,YAAY,IAC1B,CACF,ECjCA,IAAMC,EAAS,GAAK,SAAS,KAAK,OAAO,UAAU,SAAS,KAAK,CAAC,CAAC,EAAE,CAAC,EAQzDC,EAAN,cAAgC,KAAM,CAQ3C,YAAYC,EAAOC,EAAK,CACtB,MAAM,GAAGH,EAAOE,CAAK,CAAC,oCAAoCC,CAAG,IAAI,EACjE,OAAO,OAAO,KAAM,CAAE,MAAAD,EAAO,IAAAC,CAAI,CAAC,CACpC,CASA,IAAK,OAAO,WAAW,GAAI,CACzB,OAAO,KAAK,YAAY,IAC1B,CACF,ECxBO,IAAMC,EAAN,KAAkB,CAUvB,YAAYC,EAAOC,EAAgB,GAAO,CACxC,KAAK,QAAU,GACf,KAAK,cAAgBA,EACrB,KAAK,MAAQD,EACb,KAAK,UACHA,EAAM,OAAO,MACbA,EAAM,OAAO,aAAa,MAC1B,SAAS,KAAK,OAAO,UAAU,SAAS,KAAKA,EAAM,KAAK,CAAC,EAAE,CAAC,EAE9D,KAAK,MAAQ,CACX,iBAAkB,GAClB,eAAgB,EAClB,CACF,CAWA,OAAQ,CACN,OAAK,KAAK,UACR,KAAK,MAAM,iBAAmB,CAAC,KAAK,MAAM,QAC1C,KAAK,MAAM,eAAiB,KAAK,MAAM,QACvC,KAAK,QAAU,GAEX,KAAK,MAAM,kBACb,KAAK,MAAM,MAAM,GAId,IACT,CASA,MAAO,CACL,OAAI,KAAK,WACH,KAAK,eAAiB,KAAK,MAAM,UACnC,KAAK,MAAM,OAAO,EAGpB,KAAK,MAAM,iBAAmB,GAC9B,KAAK,MAAM,eAAiB,GAC5B,KAAK,QAAU,IAGV,IACT,CAMA,IAAK,OAAO,WAAW,GAAI,CACzB,MAAO,GAAG,KAAK,YAAY,IAAI,IAAI,KAAK,SAAS,EACnD,CAWA,CAAC,OAAO,IAAI,4BAA4B,CAAC,EAAEE,EAAOC,EAASC,EAAS,CAClE,IAAMC,EAAU,KAAK,OAAO,WAAW,EACjCC,EAAS,aAAa,KAAK,OAAO,YAAY,KAAK,MAAM,gBAAgB,IAE/E,OAAOF,EAAQ,GAAGC,CAAO,IAAIC,CAAM,GAAI,CAAC,GAAGH,EAAS,MAAAD,CAAK,CAAC,CAC5D,CACF,EC9FO,IAAMK,EAAN,KAAiB,CAgBtB,YAAYC,EAAUC,EAAe,WAAYC,EAAY,OAAW,CACtE,IAAMC,EAAaC,GAAWA,GAAU,KAClCC,EAAQ,CAACD,EAAOE,EAAQ,CAAC,SAAU,QAAQ,IAC/C,CAACH,EAAUC,CAAK,GAAM,CAAC,CAACE,EAAM,KAAKC,GAAKA,IAAO,OAAOH,CAAM,EACxDI,EAAWJ,GAASC,EAAMD,EAAO,CAAC,QAAQ,CAAC,EAEjD,GAAI,CAACC,EAAML,CAAQ,EACjB,cAAQ,MACN,WAAYA,EAAU,UAAU,OAAOA,CAAQ,IAC/C,eAAgBC,EAAc,UAAU,OAAOA,CAAY,IAC3D,YAAaC,EAAW,UAAU,OAAOA,CAAS,GACpD,EACM,IAAI,UAAU,yDAAyD,EAG/E,GAAI,CAACM,EAASP,CAAY,EACxB,MAAM,IAAI,UAAU,uDAAuD,EAG7E,OAAO,OAAO,KAAM,CAClB,IAAKD,EACL,WAAY,OAAO,yBAAyBC,EAAcD,CAAQ,EAClE,MAAOC,EACP,UAAY,OAAOC,GAAc,WAAcA,EAAY,MAC7D,CAAC,CACH,CAQA,IAAI,UAAW,CACb,OAAI,KAAK,WACA,KAAK,WAAW,IAAI,KAAK,KAAK,KAAK,EAAE,KAAK,EAG1C,KAAK,WAAW,KAE3B,CAOA,IAAI,QAAS,CACX,OAAO,QAAQ,IAAI,KAAK,WAAY,OAAO,CAC7C,CAOA,IAAI,YAAa,CACf,OAAO,QAAQ,IAAI,KAAK,WAAY,KAAK,CAC3C,CAOA,IAAI,YAAa,CACf,OACG,QAAQ,IAAI,KAAK,WAAY,cAAc,GAAK,CAAC,KAAK,WAAW,cACjE,QAAQ,IAAI,KAAK,WAAY,UAAU,GAAK,CAAC,KAAK,WAAW,QAElE,CAUA,IAAI,WAAY,CAMd,OAJE,KAAK,WACL,OAAO,KAAK,WAAc,WAGH,KAAK,UAAU,EAAI,EAC9C,CAcA,QAAQO,EAAeC,EAAgB,GAAO,CAC5C,IAAMC,EAAa,CAAE,GAAG,KAAK,UAAW,EAEpCD,IACE,OAAOC,EAAW,KAAQ,aAC5BA,EAAW,IAAMA,EAAW,IAAI,KAAK,KAAK,KAAK,GAE7C,OAAOA,EAAW,KAAQ,aAC5BA,EAAW,IAAMA,EAAW,IAAI,KAAK,KAAK,KAAK,IAInD,OAAO,eAAeF,EAAe,KAAK,IAAKE,CAAU,CAC3D,CAQA,IAAK,OAAO,WAAW,GAAI,CACzB,OAAO,KAAK,YAAY,IAC1B,CAWA,CAAC,OAAO,IAAI,4BAA4B,CAAC,EAAEC,EAAOC,EAASC,EAAS,CAClE,IAAMC,EAAO,KAAK,OAAS,QAAU,YAC/BC,EAAW,KAAK,WAAa,cAAgB,GAEnD,MAAO,cAAc,KAAK,GAAG,GAAGD,CAAI,GAAGC,CAAQ,GACjD,CACF,EC3JO,IAAMC,EAAN,MAAMC,CAAM,CAQjB,eAAiB,CAAC,EASlB,aAAe,CAAC,EAShB,aAAe,OASf,WAAa,EASb,eAAiB,EAkCjB,YAAYC,EAAOC,EAASC,EAAU,CAAC,EAAG,CACxC,OAAO,OAAO,KAAM,CAClB,MAAAF,EACA,QAAAE,CACF,CAAC,EAED,KAAK,aAAeD,EAEpB,IAAME,EAAkB,MAAM,QAAQ,UAEtC,QAAQ,QAAQF,CAAO,EAAE,QAAQG,GAAO,CACtC,IAAMC,EAAY,MAAM,SAAS,aAAaD,CAAG,GAAKD,EACtD,GAAI,CACF,KAAK,aAAaC,CAAG,EAAI,IAAIE,EAAWF,EAAK,KAAK,aAAcC,CAAS,EACzE,KAAK,YAAc,CACrB,OACOE,EAAO,CACZ,QAAQ,MAAM,+BAA+BH,CAAG;AAAA,EAAMG,CAAK,CAC7D,CAEA,GAAI,QAAQ,IAAI,KAAK,MAAOH,CAAG,EAC7B,GAAI,CACF,KAAK,eAAeA,CAAG,EAAI,IAAIE,EAAWF,EAAK,KAAK,KAAK,CAC3D,OACOG,EAAO,CACZ,QAAQ,MAAM,wCAAwCH,CAAG;AAAA,EAAMG,CAAK,CACtE,CAEJ,CAAC,EAEIR,EAAM,QAAQ,IAAIC,CAAK,GAC1BD,EAAM,QAAQ,IAAIC,EAAO,CAAC,CAAC,EAG7BD,EAAM,QAAQ,IAAIC,CAAK,EAAE,KAAK,IAAI,CACpC,CAOA,IAAI,SAAU,CACZ,OAAO,QAAQ,QAAQ,KAAK,YAAY,EAAE,IAAII,GACrC,CAACA,EAAK,KAAK,aAAaA,CAAG,CAAC,CACpC,CACH,CAYA,IAAI,gBAAiB,CACnB,OAAO,QACL,QAAQ,KAAK,YAAY,EACzB,OAAOA,GAAO,KAAK,WAAW,IAAIA,CAAG,IAAM,EAAI,EAC/C,IAAIA,GACK,CAACA,EAAK,KAAK,aAAaA,CAAG,CAAC,CACpC,CACL,CAYA,IAAI,kBAAmB,CACrB,OAAO,QACL,QAAQ,KAAK,YAAY,EACzB,OAAOA,GAAO,KAAK,WAAW,IAAIA,CAAG,IAAM,EAAK,EAChD,IAAIA,GACK,CAACA,EAAK,KAAK,aAAaA,CAAG,CAAC,CACpC,CACL,CAWA,IAAI,SAAU,CACZ,OAAO,KAAK,QAAQ,OAAO,CAACI,EAAK,CAACJ,EAAKK,CAAU,KAC/CD,EAAIJ,CAAG,EAAIK,EAAW,SACfD,GACN,CAAC,CAAC,CACP,CAWA,IAAI,gBAAiB,CACnB,OAAO,KAAK,QAAQ,OAAO,CAACA,EAAK,CAACJ,EAAKK,CAAU,KAC3C,KAAK,WAAW,IAAIL,CAAG,IAAM,KAC/BI,EAAIJ,CAAG,EAAIK,EAAW,UAEjBD,GACN,CAAC,CAAC,CACP,CAgBA,IAAI,kBAAmB,CACrB,OAAO,KAAK,QAAQ,OAAO,CAACA,EAAK,CAACJ,EAAKK,CAAU,KAC3C,KAAK,WAAW,IAAIL,CAAG,IAAM,KAC/BI,EAAIJ,CAAG,EAAIK,EAAW,UAEjBD,GACN,CAAC,CAAC,CACP,CAWA,IAAI,WAAY,CACd,OAAO,KAAK,QAAQ,IAAI,CAAC,CAACJ,EAAKM,CAAC,IAAMN,CAAG,CAC3C,CAQA,IAAI,WAAY,CACd,OAAO,QAAQ,QAAQ,KAAK,cAAc,EAAE,IAAIA,GACvC,CAACA,EAAK,KAAK,eAAeA,CAAG,CAAC,CACtC,CACH,CAOA,IAAI,SAAU,CACZ,OAAO,KAAK,eAAiB,CAC/B,CAOA,IAAI,oBAAqB,CACvB,OAAO,KAAK,OACd,CAQA,IAAI,gBAAiB,CACnB,OAAO,KAAK,YAAc,KAAK,cACjC,CAsCA,MAAMO,EAAS,CACb,IAAMC,EAAU,KAAK,QACfC,EAAS,CACb,QAASD,EAAQ,OACjB,QAAS,EACT,OAAQ,CAAC,EACT,WAAYA,EAAQ,MACtB,EAEA,KAAK,WAAW,MAAM,EAEtBA,EAAQ,QAAQ,CAAC,CAAC,CAACE,CAAK,IAAM,CAC5B,GAAIA,EAAM,UAAW,CAEnB,OAAO,eAAe,KAAK,MAAOA,EAAM,IAAKA,EAAM,UAAU,EAG7D,IAAIC,EAAQ,OAAO,yBAAyB,KAAK,MAAOD,EAAM,GAAG,EAC7D,KAAKE,GAAkBD,EAAOD,EAAM,UAAU,GAChDD,EAAO,SAAW,EAClBA,EAAO,YAAc,EAErB,KAAK,WAAW,IAAIC,EAAO,EAAI,IAI/BD,EAAO,OAAO,KAAK,CAACC,EAAO,IAAI,MAC7B,iCAAiCA,EAAM,GAAG,EAC5C,CAAC,CAAC,EACF,KAAK,WAAW,IAAIA,EAAO,EAAK,EAEpC,MAEE,KAAK,WAAW,IAAIA,EAAO,EAAK,CAEpC,CAAC,EAED,KAAK,eAAiBD,EAAO,QAEzB,OAAOF,GAAY,YACrBA,EAAQE,CAAM,CAElB,CAWA,aAAaI,EAAgB,GAAO,CAClC,OAAO,IAAIC,EAAY,KAAMD,CAAa,CAC5C,CA0CA,OAAON,EAAS,CACd,GAAI,CAAC,KAAK,QACR,OAGF,IAAMC,EAAU,KAAK,QACfO,EAAY,KAAK,UAEjBN,EAAS,CACb,QAASD,EAAQ,OACjB,SAAU,EACV,SAAU,EACV,UAAWO,EAAU,OACrB,OAAQ,CAAC,EACT,aAAc,CAChB,EAEAP,EAAQ,QAAQ,CAAC,CAAC,CAACE,CAAK,IAAM,CACT,OAAO,KAAK,MAAMA,EAAM,GAAG,GAE5C,KAAK,gBAAkB,EACvBD,EAAO,UAAY,EACnB,KAAK,WAAW,IAAIC,EAAO,EAAK,GAGhCD,EAAO,OAAO,KAAK,CAACC,EAAO,IAAI,MAC7B,0BAA0BA,EAAM,GAAG,EACrC,CAAC,CAAC,CAEN,CAAC,EAEDK,EAAU,QAAQ,CAAC,CAAC,CAACL,CAAK,IAAM,CAC9B,OAAO,eAAe,KAAK,MAAOA,EAAM,IAAKA,EAAM,UAAU,EAC7D,IAAMM,EAAoB,OAAO,yBAAyB,KAAK,MAAON,EAAM,GAAG,EAC3E,KAAKE,GAAkBF,EAAM,WAAYM,CAAiB,EAC5DP,EAAO,UAAY,EAGnBA,EAAO,OAAO,KAAK,CAACC,EAAO,IAAI,MAC7B,8BAA8BA,EAAM,GAAG,EACzC,CAAC,CAAC,CAEN,CAAC,EAEDD,EAAO,aAAe,KAAK,eACvB,OAAOF,GAAY,YACrBA,EAAQE,CAAM,CAElB,CAOA,SAAU,CACR,IAAMZ,EAAUF,EAAM,QAAQ,IAAI,KAAK,KAAK,EAC5CE,EAAQ,OAAOA,EAAQ,KAAK,GAAK,IAAM,IAAI,EAAG,CAAC,CACjD,CAKA,MAAQ,KAKR,QAAU,KAOV,WAAa,IAAI,IAUjB,CAAC,OAAO,QAAQ,GAAI,CAClB,OAAO,KAAK,QAAQ,OAAO,CAC7B,CAeAe,GAAkBK,EAAMC,EAAO,CAC7B,MAAI,CAACD,GAAQ,CAACC,EACL,GAIPD,EAAK,eAAiBC,EAAM,cAC5BD,EAAK,aAAeC,EAAM,YAC1BD,EAAK,QAAUC,EAAM,OACrBD,EAAK,WAAaC,EAAM,UACxBD,EAAK,MAAQC,EAAM,KACnBD,EAAK,MAAQC,EAAM,GAEvB,CAiBA,CAAC,OAAO,IAAI,4BAA4B,CAAC,EAAEC,EAAOrB,EAASsB,EAAS,CAClE,IAAMC,EAAQ,CACZ,IAAI,QAAS,CAAE,MAAO,wCAAyC,EAC/D,IAAI,QAAS,CAAE,MAAO,sCAAuC,CAC/D,EACMC,EAAO,CAAE,GAAGxB,EAAS,MAAAqB,CAAM,EAC3BI,EAAO,KAAK,OAAO,MAAQ,GAC3BC,EAAQD,EAAK,OACf,IAAIH,EAAQG,EAAMzB,CAAO,EAAE,WAAWuB,EAAM,OAAQ,MAAM,CAAC,IAC3D,GAEEI,EACJL,EAAQ,KAAK,UAAWE,CAAI,EACzB,WAAWD,EAAM,OAAQ,MAAM,EAC/B,WAAW,WAAY,IAAI,EAEhC,MAAO,GAAG,KAAK,YAAY,IAAI,GAAGG,CAAI,MAAMC,CAAI,IAClD,CAKA,OAAO,QAAU,IAAI,IASrB,OAAO,UAAU7B,EAAO,CACtB,GAAID,EAAM,QAAQ,IAAIC,CAAK,EACzB,QAAWc,KAASf,EAAM,QAAQ,IAAIC,CAAK,EACzCc,EAAM,MAAM,CAGlB,CASA,OAAO,WAAWd,EAAO,CACvB,GAAID,EAAM,QAAQ,IAAIC,CAAK,EACzB,QAAWc,KAASf,EAAM,QAAQ,IAAIC,CAAK,EACzCc,EAAM,OAAO,CAGnB,CAaA,WAAW,SAAU,CACnB,OAAO,KAAKgB,GAAoB,WAAY,EAAI,CAClD,CAcA,WAAW,OAAQ,CACjB,OAAO,KAAKA,GAAoB,WAAY,EAAK,CACnD,CAcA,WAAW,KAAM,CACf,OAAO,KAAKA,GAAoB,WAAY,GAAO,EAAI,CACzD,CAaA,WAAW,MAAO,CAChB,OAAO,KAAKA,GAAoB,WAAY,GAAO,GAAO,EAAI,CAChE,CAeA,OAAO,SAAS9B,EAAO,CACrB,IAAM+B,EAAc,CAClB/B,EACAgC,EACAC,EAAe,GACfC,EAAiB,KAEV,KAAKJ,GACV9B,EACAgC,EACAC,EACAC,CACF,EAGF,MAAO,CAQL,IAAI,SAAU,CACZ,OAAOH,EAAY/B,EAAO,GAAM,EAAK,CACvC,EASA,IAAI,OAAQ,CACV,OAAO+B,EAAY/B,EAAO,GAAO,EAAK,CACxC,EASA,IAAI,KAAM,CACR,OAAO+B,EAAY/B,EAAO,GAAO,EAAI,CACvC,EAUA,IAAI,MAAO,CACT,OAAO+B,EAAY/B,EAAO,GAAO,GAAO,EAAI,CAC9C,CACF,CACF,CAsBA,MAAO8B,GACL9B,EACAmC,EACAF,EAAe,GACfC,EAAiB,GACjB,CACA,MAAO,CAAC,GAAGnC,EAAM,QAAQ,OAAO,CAAC,EAC/B,KAAK,EACL,OAAOe,GAASA,EAAM,QAAUd,CAAK,EACrC,OAAO,CAACoC,EAAatB,IAAU,CAC7B,OAAW,CAAC,CAACL,CAAU,IAAKK,EAAM,QAChC,GAAI,EAAAqB,GAAerB,EAAM,WAAW,IAAIL,CAAU,IAAM,IAIxD,IAAIwB,EAAc,CAChBG,EAAY3B,EAAW,GAAG,EAAI,MAAO4B,GAAU,CAC7C,GAAI,OAAOA,GAAU,WACnB,OAGF,IAAMV,EAAO,OAAO,UAAU,SAAS,KAAKU,CAAK,EAC3CC,EAASxB,EAAM,aAAa,EAElCwB,EAAO,MAAM,EACmBX,IAA7B,yBACD,MAAMU,EAAM5B,EAAW,SAAUA,CAAU,EAG3C4B,EAAM5B,EAAW,SAAUA,CAAU,EAEvC6B,EAAO,KAAK,CACd,EAEA,QACF,CAEA,GAAIJ,EAAgB,CAClB,OAAO,eAAeE,EAAa3B,EAAW,IAAK,CACjD,KAAM,CACJ,OAAAK,EAAM,MAAM,EACLL,EAAW,QACpB,EACA,WAAY,GACZ,aAAc,EAChB,CAAC,EAED,QACF,CAGA,GAAIA,EAAW,WAAY,CACzB,IAAI8B,EAAU,oBAAoB,OAAO9B,EAAW,GAAG,CAAC,GACpD+B,EAAmB,CACrB,CAACD,CAAO,EAAEE,EAAS,CACjB,OAAAhC,EAAW,QAAQgC,CAAO,EACnBA,CACT,CACF,EAEAL,EAAY3B,EAAW,GAAG,EAAI+B,EAAiBD,CAAO,CACxD,MAEE9B,EAAW,QAAQ2B,CAAW,EAIlC,OAAOA,CACT,EAAG,CAAC,CAAC,CACT,CAOA,WAAW,eAAgB,CACzB,OAAO,OAAO,IAAI,4BAA4B,CAChD,CAWA,OAAO,YAAYM,EAAY,CAC7B,OAAOA,EACJ,WACC,oDACA,MACF,EACC,WACC,kBACA,IACF,CACJ,CACF,ECt1BA,IAAMC,EAAa,CAAC,SAAU,UAAW,SAAU,SAAU,QAAQ,EAWxDC,EAAN,MAAMC,UAAkBC,CAAM,CAqBnC,YAAYC,EAAcC,EAAOC,EAAQ,WAAYC,EAAU,CAAC,EAAG,CACjE,IAAMC,EAAWN,EAAU,eAAeE,CAAY,EAClD,CAAE,IAAAK,EAAK,UAAAC,EAAW,MAAAC,CAAM,EAAIH,EAGhC,GAFAE,EAAYL,GAASK,EAEjB,CAACC,EACH,MAAM,IAAIC,EAAkBN,EAAOG,CAAG,EAGxC,IAAMI,EAAa,OAAO,yBAAyBP,EAAOG,CAAG,EAC7D,GAAII,IAEC,QAAQ,IAAIA,EAAY,UAAU,GAAK,CAACA,EAAW,UACnD,QAAQ,IAAIA,EAAY,cAAc,GAAK,CAACA,EAAW,cAExD,MAAM,IAAIC,EAAsBR,EAAOG,CAAG,EAI9C,MAAMH,EAAO,CAAE,CAACG,CAAG,EAAGC,CAAU,EAAGH,CAAO,EAC1C,KAAK,IAAME,EAEX,KAAK,MAAQD,EAAS,MACtB,KAAK,SAAWA,EAAS,QAC3B,CAQA,IAAI,YAAa,CAAE,MAAO,CAAC,CAAE,KAAK,QAAU,CAQ5C,IAAI,SAAU,CAAE,MAAO,CAAC,CAAE,KAAK,KAAO,CAQtC,IAAI,aAAc,CAChB,MAAO,CAACR,EAAW,QAAQ,OAAO,KAAK,KAAK,CAC9C,CASA,IAAI,UAAW,CACb,OAAO,OAAO,KAAK,KAAK,IAAM,KAAK,KACrC,CAaA,WAAW,SAAU,CACnB,OAAOG,EAAM,OACf,CAcA,WAAW,OAAQ,CACjB,OAAOA,EAAM,KACf,CAcA,WAAW,KAAM,CACf,OAAOA,EAAM,GACf,CAaA,WAAW,MAAO,CAChB,OAAOA,EAAM,IACf,CAgBA,OAAO,SAASG,EAAO,CACrB,OAAOH,EAAM,SAASG,CAAK,CAC7B,CAcA,OAAO,eAAeF,EAAc,CAClC,IAAIW,EAAQ,CAAE,IAAK,KAAM,UAAW,KAAM,MAAO,EAAM,EAEvD,OAAIX,aAAwB,UAC1BW,EAAQ,CACN,IAAKX,EAAa,KAClB,UAAWA,EACX,MAAO,EACT,EAEI,YAAY,KAAKA,EAAa,SAAS,CAAC,IAC1CW,EAAM,MAAQX,GAGZ,wBAAwB,KAAKA,EAAa,SAAS,CAAC,IACtDW,EAAM,SAAWX,KAGZ,OAAOA,GAAiB,UAAYA,aAAwB,UACnEW,EAAQ,CAAE,IAAKX,EAAc,UAAW,KAAM,MAAO,EAAK,GAGrDW,CACT,CAWA,CAAC,OAAO,IAAI,4BAA4B,CAAC,EAAEC,EAAOT,EAASU,EAAS,CAClE,IAAMC,EAAQ,CACZ,IAAI,QAAS,CAAE,MAAO,4CAA6C,EACnE,IAAI,QAAS,CAAE,MAAO,wCAAyC,CACjE,EAEMT,EAAMQ,EAAQ,KAAK,IAAKV,CAAO,EAAE,WAAWW,EAAM,OAAQ,MAAM,EAChEC,EACJF,EAAQ,KAAK,QAAQ,KAAK,GAAG,EAAGV,CAAO,EACtC,WAAWW,EAAM,OAAQ,MAAM,EAGlC,MAAO,aAAaT,CAAG,IAAIU,CAAG,GAChC,CAQA,IAAK,OAAO,WAAW,GAAI,CACzB,OAAO,KAAK,YAAY,IAC1B,CAWA,OAAO,UAAUC,KAASC,EAAY,CACpC,OAAO,IAAInB,EAAU,aAAakB,EAAM,GAAGC,CAAU,CACvD,CAKA,OAAO,aAAe,KAAmB,CAQvC,YAAYD,KAASC,EAAY,CAC/B,KAAK,KAAOD,EACZ,KAAK,iBAAmB,IAAI,IAC5B,KAAK,WAAa,IAAI,IAEtB,QAAWE,KAAkBD,EACvBC,aAA0BpB,GAC5B,KAAK,WAAW,IAAIoB,CAAc,EAClC,KAAK,iBAAiB,IAAIA,EAAe,QAAQA,EAAe,GAAG,CAAC,GAC3DA,aAA0B,WACnC,KAAK,iBAAiB,IAAIA,CAAc,EACxC,KAAK,WAAW,IAAI,IAAIpB,EAAUoB,CAAc,CAAC,EAGvD,CAKA,OAAQ,CACN,QAAWZ,KAAa,KAAK,WAC3BA,EAAU,MAAM,CAEpB,CAKA,QAAS,CACP,QAAWA,KAAa,KAAK,WAC3BA,EAAU,OAAO,CAErB,CACF,CACF,EN7SO,IAAMa,EAAS,CACpB,IAAI,kBAAmB,CAAE,OAAOC,CAAsB,EACtD,IAAI,mBAAoB,CAAE,OAAOC,CAAkB,CACrD",
  "names": ["src_exports", "__export", "Errors", "Extension", "Patch", "PatchEntry", "PatchToggle", "typeOf", "CannotBeExtendedError", "owner", "key", "typeOf", "MissingOwnerValue", "owner", "key", "PatchToggle", "patch", "preventRevert", "depth", "options", "inspect", "objName", "status", "PatchEntry", "property", "owningObject", "condition", "isNullish", "value", "isKey", "types", "f", "isObject", "anotherObject", "bindAccessors", "descriptor", "depth", "options", "inspect", "type", "writable", "Patch", "_Patch", "owner", "patches", "options", "globalCondition", "key", "condition", "PatchEntry", "error", "acc", "patchEntry", "_", "metrics", "entries", "counts", "patch", "oDesc", "#equalDescriptors", "preventRevert", "PatchToggle", "conflicts", "appliedDescriptor", "left", "right", "depth", "inspect", "exprs", "opts", "type", "name", "keys", "#allPatchesForOwner", "allForOwner", "appliedOnly", "wrapInToggle", "applyOnRequest", "onlyApplied", "accumulator", "usage", "toggle", "dynName", "dynNameContainer", "applyTo", "fromString", "primitives", "Extension", "_Extension", "Patch", "keyClassOrFn", "value", "owner", "options", "metadata", "key", "extension", "valid", "MissingOwnerValue", "descriptor", "CannotBeExtendedError", "input", "depth", "inspect", "exprs", "val", "name", "extensions", "extensionValue", "Errors", "CannotBeExtendedError", "MissingOwnerValue"]
}
